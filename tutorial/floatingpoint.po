# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-01 22:23+0200\n"
"PO-Revision-Date: 2024-05-30 09:19+0200\n"
"Last-Translator: Alessandro Cucci <alessandro.cucci@gmail.com>\n"
"Language-Team: \n"
"Language: it_IT\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 2.2.1\n"

#: tutorial/floatingpoint.rst:10
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "Aritmetica con i Numeri in Virgola Mobile: Problemi e Limitazioni"

#: tutorial/floatingpoint.rst:16
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the **decimal** fraction ``0.625`` has "
"value 6/10 + 2/100 + 5/1000, and in the same way the **binary** fraction "
"``0.101`` has value 1/2 + 0/4 + 1/8. These two fractions have identical "
"values, the only real difference being that the first is written in base 10 "
"fractional notation, and the second in base 2."
msgstr ""
"I numeri in virgola mobile sono rappresentati nell'hardware del computer "
"come frazioni in base 2 (binari). Ad esempio, la frazione **decimale** "
"``0.625`` ha valore 6/10 + 2/100 + 5/1000, e allo stesso modo la frazione "
"**binaria** ``0.101`` ha valore 1/2 + 0/4 + 1/8. Queste due frazioni hanno "
"valori identici, l'unica vera differenza è che la prima è scritta in "
"notazione frazionaria in base 10, e la seconda in base 2."

#: tutorial/floatingpoint.rst:23
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"Sfortunatamente, la maggior parte delle frazioni decimali non può essere "
"rappresentata esattamente come frazioni binarie. Una conseguenza è che, in "
"generale, i numeri in virgola mobile decimali che inserisci sono solo "
"approssimati dai numeri in virgola mobile binari effettivamente memorizzati "
"nella macchina."

#: tutorial/floatingpoint.rst:28
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"Il problema è più facile da comprendere inizialmente in base 10. Considera "
"la frazione 1/3. Puoi approssimarla come una frazione in base 10::"

#: tutorial/floatingpoint.rst:37
msgid "or, better, ::"
msgstr "o, meglio, ::"

#: tutorial/floatingpoint.rst:41
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"e così via. Non importa quanti cifre sei disposto a scrivere, il risultato "
"non sarà mai esattamente 1/3, ma sarà una approssimazione sempre migliore di "
"1/3."

#: tutorial/floatingpoint.rst:45
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"Allo stesso modo, non importa quante cifre in base 2 sei disposto a usare, "
"il valore decimale 0.1 non può essere rappresentato esattamente come una "
"frazione in base 2. In base 2, 1/10 è la frazione che si ripete "
"all'infinito::"

#: tutorial/floatingpoint.rst:51
msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"Fermati a un qualsiasi numero finito di bit, e otterrai un'approssimazione. "
"Nella maggior parte delle macchine odierne, i float sono approssimati usando "
"una frazione binaria con il numeratore che utilizza i primi 53 bit a partire "
"dal bit più significativo e con il denominatore come potenza di due. Nel "
"caso di 1/10, la frazione binaria è ``3602879701896397 / 2 ** 55`` che è "
"vicino ma non esattamente uguale al valore vero di 1/10."

#: tutorial/floatingpoint.rst:58
msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display::"
msgstr ""
"Molti utenti non sono a conoscenza dell'approssimazione a causa del modo in "
"cui i valori sono visualizzati. Python stampa solo un'approssimazione "
"decimale al valore decimale vero dell'approssimazione binaria memorizzata "
"nella macchina. Nella maggior parte delle macchine, se Python dovesse "
"stampare il valore decimale vero dell'approssimazione binaria memorizzata "
"per 0.1, dovrebbe visualizzare::"

#: tutorial/floatingpoint.rst:67
msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead:"
msgstr ""
"Questo è un numero di cifre maggiore di quelle che la maggior parte delle "
"persone trova utile, quindi Python mantiene il numero di cifre gestibile "
"visualizzando invece un valore arrotondato:"

#: tutorial/floatingpoint.rst:75
msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"Ricorda solo, anche se il risultato stampato sembra il valore esatto di "
"1/10, il valore effettivamente memorizzato è la frazione binaria "
"rappresentabile più vicina."

#: tutorial/floatingpoint.rst:78
msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Interessante è che ci sono molti numeri decimali diversi che condividono la "
"stessa frazione binaria approssimata più vicina. Ad esempio, i numeri "
"``0.1`` e ``0.10000000000000001`` e "
"``0.1000000000000000055511151231257827021181583404541015625`` sono tutti "
"approssimati da ``3602879701896397 / 2 ** 55``. Poiché tutti questi valori "
"decimali condividono la stessa approssimazione, qualsiasi di essi potrebbe "
"essere visualizzato pur mantenendo l'invariante ``eval(repr(x)) == x``."

#: tutorial/floatingpoint.rst:86
msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"Storicamente, il prompt di Python e la funzione integrata :func:`repr` "
"avrebbero scelto quella con 17 cifre significative, ``0.10000000000000001``. "
"A partire da Python 3.1, Python (sulla maggior parte dei sistemi) è ora in "
"grado di scegliere il più corto di questi e visualizzare semplicemente "
"``0.1``."

#: tutorial/floatingpoint.rst:91
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Nota che questa è la natura stessa della virgola mobile binaria: non è un "
"bug di Python e non è nemmeno un bug nel tuo codice. Vedrai lo stesso tipo "
"di cosa in tutti i linguaggi che supportano l'aritmetica in virgola mobile "
"del tuo hardware (anche se alcuni linguaggi potrebbero non *visualizzare* la "
"differenza per impostazione predefinita o in tutte le modalità di output)."

#: tutorial/floatingpoint.rst:97
msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits:"
msgstr ""
"Per un output più gradevole, potresti voler usare la formattazione delle "
"stringhe per produrre un numero limitato di cifre significative:"

#: tutorial/floatingpoint.rst:111
msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr ""
"È importante rendersi conto che questo è, in un certo senso, un'illusione: "
"stai semplicemente arrotondando la *visualizzazione* del vero valore della "
"macchina."

#: tutorial/floatingpoint.rst:114
msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either:"
msgstr ""
"Un'illusione può generare un'altra. Ad esempio, poiché 0.1 non è esattamente "
"1/10, sommare tre valori di 0.1 potrebbe non dare esattamente 0.3, nemmeno:"

#: tutorial/floatingpoint.rst:122
msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help:"
msgstr ""
"Inoltre, poiché lo 0.1 non può avvicinarsi al valore esatto di 1/10 e lo 0.3 "
"non può avvicinarsi al valore esatto di 3/10, il pre-arrotondamento con la "
"funzione :func:`round` non può aiutare:"

#: tutorial/floatingpoint.rst:131
msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`math.isclose` function can be useful for comparing inexact values:"
msgstr ""
"Anche se i numeri non possono essere resi più vicini ai loro valori esatti "
"previsti, la funzione :func:`math.isclose` può essere utile per confrontare "
"valori inesatti:"

#: tutorial/floatingpoint.rst:139
msgid ""
"Alternatively, the :func:`round` function can be used to compare rough "
"approximations:"
msgstr ""
"In alternativa, la funzione :func:`round` può essere utilizzata per "
"confrontare approssimazioni grossolane:"

#: tutorial/floatingpoint.rst:147
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `Examples of Floating Point Problems "
"<https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/>`_ for "
"a pleasant summary of how binary floating-point works and the kinds of "
"problems commonly encountered in practice.  Also see `The Perils of Floating "
"Point <http://www.indowsway.com/floatingpoint.htm>`_ for a more complete "
"account of other common surprises."
msgstr ""
"L'aritmetica con numeri in virgola mobile binari riserva molte sorprese di "
"questo tipo. Il problema con \"0.1\" è spiegato in dettaglio preciso di "
"seguito, nella sezione \"Errore di Rappresentazione\". Vedi `Examples of "
"Floating Point Problems <https://jvns.ca/blog/2023/01/13/examples-of-"
"floating-point-problems/>`_ per un riepilogo piacevole di come funziona la "
"virgola mobile binaria e dei tipi di problemi comunemente riscontrati nella "
"pratica. Vedi anche `The Perils of Floating Point <http://www.indowsway.com/"
"floatingpoint.htm>`_ per un resoconto più completo di altre sorprese comuni."

#: tutorial/floatingpoint.rst:156
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Come viene detto vicino alla fine, \"non ci sono risposte facili\". "
"Tuttavia, non essere troppo diffidente nei confronti della virgola mobile! "
"Gli errori nelle operazioni float di Python sono ereditati dall'hardware in "
"virgola mobile e nella maggior parte delle macchine sono dell'ordine di non "
"più di 1 parte su 2**53 per operazione. Questo è più che adeguato per la "
"maggior parte dei compiti, ma è necessario tenere a mente che non è "
"aritmetica decimale e che ogni operazione float può soffrire di un nuovo "
"errore di arrotondamento."

#: tutorial/floatingpoint.rst:163
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Sebbene esistano casi patologici, per la maggior parte dell'uso occasionale "
"dell'aritmetica in virgola mobile otterrai il risultato che ti aspetti alla "
"fine se semplicemente arrotondi la visualizzazione dei tuoi risultati finali "
"al numero di cifre decimali che ti aspetti. :func:`str` di solito è "
"sufficiente, e per un controllo più fine vedi gli specificatori di formato "
"del metodo :meth:`str.format` in :ref:`formatstrings`."

#: tutorial/floatingpoint.rst:169
msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"Per utilizzi che richiedono una rappresentazione decimale esatta, prova ad "
"usare il modulo :mod:`decimal` che implementa l'aritmetica decimale adatta "
"per applicazioni contabili e applicazioni ad alta precisione."

#: tutorial/floatingpoint.rst:173
msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"Un'altra forma di aritmetica esatta è supportata dal modulo :mod:`fractions` "
"che implementa l'aritmetica basata su numeri razionali (così i numeri come "
"1/3 possono essere rappresentati esattamente)."

#: tutorial/floatingpoint.rst:177
msgid ""
"If you are a heavy user of floating-point operations you should take a look "
"at the NumPy package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"Se sei un utente assiduo delle operazioni in virgola mobile, dovresti dare "
"un'occhiata al pacchetto NumPy e a molti altri pacchetti per operazioni "
"matematiche e statistiche forniti dal progetto SciPy. Vedi <https://scipy."
"org>."

#: tutorial/floatingpoint.rst:181
msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction:"
msgstr ""
"Python fornisce strumenti che possono aiutare in quelle rare occasioni in "
"cui davvero *vuoi* conoscere il valore esatto di un float. Il metodo :meth:"
"`float.as_integer_ratio` esprime il valore di un float come una frazione:"

#: tutorial/floatingpoint.rst:192
msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value:"
msgstr ""
"Poiché il rapporto è esatto, può essere utilizzato per ricreare senza "
"perdita il valore originale:"

#: tutorial/floatingpoint.rst:200
msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer:"
msgstr ""
"Il metodo :meth:`float.hex` esprime un float in esadecimale (base 16), dando "
"ancora una volta il valore esatto memorizzato dal tuo computer:"

#: tutorial/floatingpoint.rst:208
msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly:"
msgstr ""
"Questa rappresentazione esadecimale precisa può essere utilizzata per "
"ricostruire il valore del float esattamente:"

#: tutorial/floatingpoint.rst:216
msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"Poiché la rappresentazione è esatta, è utile per trasferire valori in modo "
"affidabile tra diverse versioni di Python (indipendenza dalla piattaforma) e "
"scambiare dati con altri linguaggi che supportano lo stesso formato (come "
"Java e C99)."

#: tutorial/floatingpoint.rst:220
msgid ""
"Another helpful tool is the :func:`sum` function which helps mitigate loss-"
"of-precision during summation.  It uses extended precision for intermediate "
"rounding steps as values are added onto a running total. That can make a "
"difference in overall accuracy so that the errors do not accumulate to the "
"point where they affect the final total:"
msgstr ""
"Un altro strumento utile è la funzione :func:`sum` che aiuta a mitigare la "
"perdita di precisione durante la somma. Usa la precisione estesa per i "
"passaggi di arrotondamento intermedi man mano che i valori vengono aggiunti "
"a un totale incrementale. Questo può fare la differenza in termini di "
"precisione complessiva in modo che gli errori non si accumulino al punto da "
"influenzare il totale finale:"

#: tutorial/floatingpoint.rst:233
msgid ""
"The :func:`math.fsum()` goes further and tracks all of the \"lost digits\" "
"as values are added onto a running total so that the result has only a "
"single rounding.  This is slower than :func:`sum` but will be more accurate "
"in uncommon cases where large magnitude inputs mostly cancel each other out "
"leaving a final sum near zero:"
msgstr ""
"La funzione :func:`math.fsum()` va oltre e traccia tutti i \"bit perduti\" "
"man mano che i valori vengono aggiunti a un totale incrementale in modo che "
"il risultato abbia solo un singolo arrotondamento. Questo è più lento di :"
"func:`sum` ma sarà più accurato nei casi non comuni in cui input di grande "
"magnitudine si annullano a vicenda lasciando una somma finale vicina allo "
"zero:"

#: tutorial/floatingpoint.rst:260
msgid "Representation Error"
msgstr "Errore di Rappresentazione"

#: tutorial/floatingpoint.rst:262
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"Questa sezione spiega l'esempio \"0.1\" in dettaglio, e mostra come puoi "
"eseguire un'analisi esatta di casi come questo da solo. Si assume una "
"familiarità di base con la rappresentazione in virgola mobile binaria."

#: tutorial/floatingpoint.rst:266
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
":dfn:`Errore di rappresentazione` si riferisce al fatto che alcune (anzi, la "
"maggior parte) delle frazioni decimali non possono essere rappresentate "
"esattamente come frazioni binarie (base 2). Questa è la principale ragione "
"per cui Python (o Perl, C, C++, Java, Fortran e molti altri) spesso non "
"visualizzeranno il numero decimale esatto che ti aspetti."

#: tutorial/floatingpoint.rst:271
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction.  Since "
"at least 2000, almost all machines use IEEE 754 binary floating-point "
"arithmetic, and almost all platforms map Python floats to IEEE 754 binary64 "
"\"double precision\" values.  IEEE 754 binary64 values contain 53 bits of "
"precision, so on input the computer strives to convert 0.1 to the closest "
"fraction it can of the form *J*/2**\\ *N* where *J* is an integer containing "
"exactly 53 bits. Rewriting ::"
msgstr ""
"Perché questo? 1/10 non è esattamente rappresentabile come frazione binaria. "
"Dal 2000 in poi, quasi tutte le macchine utilizzano l'aritmetica in virgola "
"mobile binaria IEEE 754, e quasi tutte le piattaforme mappano i float di "
"Python ai valori \"doppia precisione\" IEEE 754 binary64. I valori IEEE 754 "
"binary64 contengono 53 bit di precisione, quindi in input il computer cerca "
"di convertire 0.1 nella frazione più vicina della forma *J*/2**\\ *N* dove "
"*J* è un intero contenente esattamente 53 bit. Riscrivendo::"

#: tutorial/floatingpoint.rst:282
msgid "as ::"
msgstr "come::"

#: tutorial/floatingpoint.rst:286
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56:"
msgstr ""
"e ricordando che *J* ha esattamente 53 bit (è ``>= 2**52`` ma ``< 2**53``), "
"il miglior valore per *N* è 56:"

#: tutorial/floatingpoint.rst:294
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded:"
msgstr ""
"Cioè, 56 è l'unico valore per *N* che lascia *J* con esattamente 53 bit. Il "
"miglior valore possibile per *J* è quindi quel quoziente arrotondato:"

#: tutorial/floatingpoint.rst:303
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up:"
msgstr ""
"Poiché il resto è più della metà di 10, la migliore approssimazione si "
"ottiene arrotondando verso l'alto:"

#: tutorial/floatingpoint.rst:313
msgid ""
"Therefore the best possible approximation to 1/10 in IEEE 754 double "
"precision is::"
msgstr ""
"Pertanto la migliore approssimazione possibile di 1/10 in doppia precisione "
"IEEE 754 è::"

#: tutorial/floatingpoint.rst:318
msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr ""
"Dividendo sia il numeratore che il denominatore per due si riduce la "
"frazione a::"

#: tutorial/floatingpoint.rst:322
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Nota che poiché abbiamo arrotondato verso l'alto, questo è in realtà un po' "
"più grande di 1/10; se non avessimo arrotondato verso l'alto, il quoziente "
"sarebbe stato un po' più piccolo di 1/10. Ma in nessun caso può essere "
"*esattamente* 1/10!"

#: tutorial/floatingpoint.rst:326
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best IEEE 754 double approximation it can get:"
msgstr ""
"Quindi il computer non \"vede\" mai 1/10: quello che vede è la frazione "
"esatta data sopra, la migliore approssimazione doppia precisione IEEE 754 "
"che può ottenere:"

#: tutorial/floatingpoint.rst:334
msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits:"
msgstr ""
"Se moltiplichiamo quella frazione per 10**55, possiamo vedere il valore fino "
"a 55 cifre decimali:"

#: tutorial/floatingpoint.rst:342
msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits:"
msgstr ""
"il che significa che il numero esatto memorizzato nel computer è pari al "
"valore decimale 0.1000000000000000055511151231257827021181583404541015625. "
"Invece di visualizzare il valore decimale completo, molti linguaggi "
"(compresi le vecchie versioni di Python), arrotondano il risultato a 17 "
"cifre significative:"

#: tutorial/floatingpoint.rst:352
msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations easy:"
msgstr ""
"I moduli :mod:`fractions` e :mod:`decimal` rendono questi calcoli facili:"

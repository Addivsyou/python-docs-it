# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-01 22:23+0200\n"
"PO-Revision-Date: 2024-06-01 08:15+0100\n"
"Last-Translator: Alessandro Cucci <alessandro.cucci@gmail.com>\n"
"Language-Team: \n"
"Language: it_IT\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 2.2.1\n"

#: library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Tipi incorporati"

#: library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Le sezioni seguenti descrivono i tipi standard incorporati nell'interprete."

#: library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"I principali tipi incorporati sono numerici, sequenze, mappature, classi, "
"istanze ed eccezioni."

#: library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Alcune classi di collezioni sono mutabili. I metodi che aggiungono, "
"sottraggono o riorganizzano i loro membri in loco, e non restituiscono un "
"elemento specifico, non restituiscono mai l'istanza della collezione stessa "
"ma ``None``."

#: library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Alcune operazioni sono supportate da diversi tipi di oggetti; in "
"particolare, praticamente tutti gli oggetti possono essere confrontati per "
"uguaglianza, testati per valore di verità e convertiti in una stringa (con "
"la funzione :func:`repr` o la funzione leggermente diversa :func:`str`). "
"Quest'ultima funzione viene utilizzata implicitamente quando un oggetto è "
"scritto dalla funzione :func:`print`."

#: library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Test del Valore di Verità"

#: library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Qualsiasi oggetto può essere testato per valore di verità, per essere usato "
"in una condizione :keyword:`if` o :keyword:`while` o come operando delle "
"operazioni booleane sotto."

#: library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`~object.__bool__` method that returns ``False`` or a :meth:`~object."
"__len__` method that returns zero, when called with the object. [1]_  Here "
"are most of the built-in objects considered false:"
msgstr ""
"Per impostazione predefinita, un oggetto è considerato vero a meno che la "
"sua classe non definisca un metodo :meth:`~object.__bool__` che restituisce "
"``False`` o un metodo :meth:`~object.__len__` che restituisce zero, quando "
"chiamato con l’oggetto. [1]_ Ecco la maggior parte degli oggetti incorporati "
"considerati falsi:"

#: library/stdtypes.rst:56
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "costanti definite come false: ``None`` e ``False``"

#: library/stdtypes.rst:58
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"zero di qualsiasi tipo numerico: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: library/stdtypes.rst:61
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"sequenze e collezioni vuote: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"

#: library/stdtypes.rst:70
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Le operazioni e le funzioni incorporate che hanno un risultato booleano "
"restituiscono sempre ``0`` o ``False`` per false e ``1`` o ``True`` per "
"true, salvo diversa indicazione. (Eccezione importante: le operazioni "
"booleane ``or`` e ``and`` restituiscono sempre uno dei loro operandi.)"

#: library/stdtypes.rst:79
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "Operazioni Booleane — :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: library/stdtypes.rst:83
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Queste sono le operazioni booleane, ordinate per priorità crescente:"

#: library/stdtypes.rst:144 library/stdtypes.rst:366 library/stdtypes.rst:965
#: library/stdtypes.rst:1170
msgid "Operation"
msgstr "Operazione"

#: library/stdtypes.rst:276 library/stdtypes.rst:416 library/stdtypes.rst:1170
msgid "Result"
msgstr "Risultato"

#: library/stdtypes.rst:276 library/stdtypes.rst:965 library/stdtypes.rst:2419
#: library/stdtypes.rst:3637
msgid "Notes"
msgstr "Note"

#: library/stdtypes.rst:88
msgid "``x or y``"
msgstr "``x or y``"

#: library/stdtypes.rst:88
msgid "if *x* is true, then *x*, else *y*"
msgstr "se *x* è vero, allora *x*, altrimenti *y*"

#: library/stdtypes.rst:967 library/stdtypes.rst:1181 library/stdtypes.rst:3643
msgid "\\(1)"
msgstr "\\(1)"

#: library/stdtypes.rst:91
msgid "``x and y``"
msgstr "``x and y``"

#: library/stdtypes.rst:91
msgid "if *x* is false, then *x*, else *y*"
msgstr "se *x* è falso, allora *x*, altrimenti *y*"

#: library/stdtypes.rst:289 library/stdtypes.rst:1209 library/stdtypes.rst:2431
#: library/stdtypes.rst:3649
msgid "\\(2)"
msgstr "\\(2)"

#: library/stdtypes.rst:94
msgid "``not x``"
msgstr "``not x``"

#: library/stdtypes.rst:94
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "se *x* è falso, allora ``True``, altrimenti ``False``"

#: library/stdtypes.rst:979 library/stdtypes.rst:2433 library/stdtypes.rst:2437
#: library/stdtypes.rst:3651 library/stdtypes.rst:3655
#: library/stdtypes.rst:3657
msgid "\\(3)"
msgstr "\\(3)"

#: library/stdtypes.rst:320 library/stdtypes.rst:1016 library/stdtypes.rst:2465
#: library/stdtypes.rst:3687
msgid "Notes:"
msgstr "Note:"

#: library/stdtypes.rst:106
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Questo è un operatore a cortocircuito, quindi valuta il secondo argomento "
"solo se il primo è falso."

#: library/stdtypes.rst:110
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Questo è un operatore a cortocircuito, quindi valuta il secondo argomento "
"solo se il primo è vero."

#: library/stdtypes.rst:114
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` ha una priorità inferiore rispetto agli operatori non booleani, "
"quindi ``not a == b`` è interpretato come ``not (a == b)``, e ``a == not b`` "
"è un errore di sintassi."

#: library/stdtypes.rst:121
msgid "Comparisons"
msgstr "Confronti"

#: library/stdtypes.rst:135
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Ci sono otto operazioni di confronto in Python. Hanno tutte la stessa "
"priorità (che è superiore a quella delle operazioni booleane). I confronti "
"possono essere concatenati arbitrariamente; per esempio, ``x < y <= z`` è "
"equivalente a ``x < y and y <= z``, tranne che *y* è valutato solo una volta "
"(ma in entrambi i casi *z* non è valutato affatto quando ``x < y`` risulta "
"falso)."

#: library/stdtypes.rst:141
msgid "This table summarizes the comparison operations:"
msgstr "Questa tabella riassume le operazioni di confronto:"

#: library/stdtypes.rst:2396 library/stdtypes.rst:3614
#: library/stdtypes.rst:3637
msgid "Meaning"
msgstr "Significato"

#: library/stdtypes.rst:146
msgid "``<``"
msgstr "``<``"

#: library/stdtypes.rst:146
msgid "strictly less than"
msgstr "strettamente minore di"

#: library/stdtypes.rst:148
msgid "``<=``"
msgstr "``<=``"

#: library/stdtypes.rst:148
msgid "less than or equal"
msgstr "minore o uguale"

#: library/stdtypes.rst:150
msgid "``>``"
msgstr "``>``"

#: library/stdtypes.rst:150
msgid "strictly greater than"
msgstr "strettamente maggiore di"

#: library/stdtypes.rst:152
msgid "``>=``"
msgstr "``>=``"

#: library/stdtypes.rst:152
msgid "greater than or equal"
msgstr "maggiore o uguale"

#: library/stdtypes.rst:154
msgid "``==``"
msgstr "``==``"

#: library/stdtypes.rst:154
msgid "equal"
msgstr "uguale"

#: library/stdtypes.rst:156
msgid "``!=``"
msgstr "``!=``"

#: library/stdtypes.rst:156
msgid "not equal"
msgstr "diverso"

#: library/stdtypes.rst:158
msgid "``is``"
msgstr "``is``"

#: library/stdtypes.rst:158
msgid "object identity"
msgstr "identità dell'oggetto"

#: library/stdtypes.rst:160
msgid "``is not``"
msgstr "``is not``"

#: library/stdtypes.rst:160
msgid "negated object identity"
msgstr "identità dell'oggetto negata"

#: library/stdtypes.rst:167
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Oggetti di tipi diversi, eccetto diversi tipi numerici, non vengono mai "
"considerati uguali. L'operatore ``==`` è sempre definito ma per alcuni tipi "
"di oggetti (ad esempio, oggetti di classe) è equivalente a :keyword:`is`. "
"Gli operatori ``<``, ``<=``, ``>`` e ``>=`` sono definiti solo dove hanno "
"senso; ad esempio, essi sollevano un'eccezione :exc:`TypeError` quando uno "
"degli argomenti è un numero complesso."

#: library/stdtypes.rst:181
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Le istanze non identiche di una classe normalmente vengono considerate come "
"non uguali a meno che la classe definisca il metodo :meth:`~object.__eq__`."

#: library/stdtypes.rst:184
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Le istanze di una classe non possono essere ordinate rispetto ad altre "
"istanze della stessa classe, o di altri tipi di oggetti, a meno che la "
"classe non definisca abbastanza metodi :meth:`~object.__lt__`, :meth:"
"`~object.__le__`, :meth:`~object.__gt__`, e :meth:`~object.__ge__` (in "
"generale, :meth:`~object.__lt__` e :meth:`~object.__eq__` sono sufficienti, "
"se si vogliono i significati convenzionali degli operatori di confronto)."

#: library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Il comportamento degli operatori :keyword:`is` e :keyword:`is not` non può "
"essere personalizzato; inoltre possono essere applicati a qualsiasi due "
"oggetti e non sollevano mai un'eccezione."

#: library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`~object.__contains__` method."
msgstr ""
"Due operazioni con la stessa priorità sintattica, :keyword:`in` e :keyword:"
"`not in`, sono supportate da tipi che sono :term:`iterable` o implementano "
"il metodo :meth:`~object.__contains__`."

#: library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Tipi Numerici --- :class:`int`, :class:`float`, :class:`complex`"

#: library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Ci sono tre distinti tipi numerici: :dfn:`interi`, :dfn:`numeri in virgola "
"mobile`, e :dfn:`numeri complessi`. Inoltre, i booleani sono un sottotipo "
"degli interi. Gli interi hanno precisione illimitata. I numeri in virgola "
"mobile sono solitamente implementati usando :c:expr:`double` in C; "
"informazioni sulla precisione e la rappresentazione interna dei numeri in "
"virgola mobile per la macchina su cui il tuo programma è in esecuzione sono "
"disponibili in :data:`sys.float_info`. I numeri complessi hanno una parte "
"reale e una parte immaginaria, entrambe in virgola mobile. Per estrarre "
"queste parti da un numero complesso *z*, usa ``z.real`` e ``z.imag``. (La "
"libreria standard include i tipi numerici aggiuntivi :mod:`fractions."
"Fraction`, per i numeri razionali, e :mod:`decimal.Decimal`, per i numeri in "
"virgola mobile con precisione definibile dall'utente.)"

#: library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"I numeri sono creati da letterali numerici o come risultato di funzioni e "
"operatori integrati. I letterali interi non adornati (inclusi i numeri "
"esadecimali, ottali e binari) generano interi. I letterali numerici "
"contenenti un punto decimale o un segno esponenziale generano numeri in "
"virgola mobile. Aggiungendo ``'j'`` o ``'J'`` a un letterale numerico si "
"ottiene un numero immaginario (un numero complesso con parte reale zero) che "
"puoi aggiungere a un intero o a un numero in virgola mobile per ottenere un "
"numero complesso con parte reale e immaginaria."

#: library/stdtypes.rst:263
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python supporta completamente l'aritmetica mista: quando un operatore "
"aritmetico binario ha operandi di diversi tipi numerici, l'operando con il "
"tipo \"più ristretto\" viene ampliato a quello dell'altro, dove intero è più "
"ristretto di virgola mobile, che è più ristretto di complesso. Un confronto "
"tra numeri di tipi diversi si comporta come se fossero confrontati i valori "
"esatti di quei numeri. [2]_"

#: library/stdtypes.rst:269
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"I costruttori :func:`int`, :func:`float` e :func:`complex` possono essere "
"usati per produrre numeri di un tipo specifico."

#: library/stdtypes.rst:272
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Tutti i tipi numerici (eccetto i complessi) supportano le seguenti "
"operazioni (per le priorità delle operazioni, vedi :ref:`operator-summary`):"

#: library/stdtypes.rst:276
msgid "Full documentation"
msgstr "Documentazione completa"

#: library/stdtypes.rst:278
msgid "``x + y``"
msgstr "``x + y``"

#: library/stdtypes.rst:278
msgid "sum of *x* and *y*"
msgstr "somma di *x* e *y*"

#: library/stdtypes.rst:280
msgid "``x - y``"
msgstr "``x - y``"

#: library/stdtypes.rst:280
msgid "difference of *x* and *y*"
msgstr "differenza tra *x* e *y*"

#: library/stdtypes.rst:282
msgid "``x * y``"
msgstr "``x * y``"

#: library/stdtypes.rst:282
msgid "product of *x* and *y*"
msgstr "prodotto di *x* e *y*"

#: library/stdtypes.rst:284
msgid "``x / y``"
msgstr "``x / y``"

#: library/stdtypes.rst:284
msgid "quotient of *x* and *y*"
msgstr "quoziente di *x* e *y*"

#: library/stdtypes.rst:286
msgid "``x // y``"
msgstr "``x // y``"

#: library/stdtypes.rst:286
msgid "floored quotient of *x* and *y*"
msgstr "quoziente di *x* e *y* arrotondato per difetto"

#: library/stdtypes.rst:286
msgid "\\(1)\\(2)"
msgstr "\\(1)\\(2)"

#: library/stdtypes.rst:289
msgid "``x % y``"
msgstr "``x % y``"

#: library/stdtypes.rst:289
msgid "remainder of ``x / y``"
msgstr "resto della divisione ``x / y``"

#: library/stdtypes.rst:291
msgid "``-x``"
msgstr "``-x``"

#: library/stdtypes.rst:291
msgid "*x* negated"
msgstr "*x* negato"

#: library/stdtypes.rst:293
msgid "``+x``"
msgstr "``+x``"

#: library/stdtypes.rst:293
msgid "*x* unchanged"
msgstr "*x* invariato"

#: library/stdtypes.rst:295
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: library/stdtypes.rst:295
msgid "absolute value or magnitude of *x*"
msgstr "valore assoluto o magnitudine di *x*"

#: library/stdtypes.rst:295
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: library/stdtypes.rst:298
msgid "``int(x)``"
msgstr "``int(x)``"

#: library/stdtypes.rst:298
msgid "*x* converted to integer"
msgstr "*x* convertito in intero"

#: library/stdtypes.rst:298
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: library/stdtypes.rst:298
msgid ":func:`int`"
msgstr ":func:`int`"

#: library/stdtypes.rst:300
msgid "``float(x)``"
msgstr "``float(x)``"

#: library/stdtypes.rst:300
msgid "*x* converted to floating point"
msgstr "*x* convertito in numero in virgola mobile"

#: library/stdtypes.rst:300
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: library/stdtypes.rst:300
msgid ":func:`float`"
msgstr ":func:`float`"

#: library/stdtypes.rst:302
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: library/stdtypes.rst:302
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"un numero complesso con parte reale *re* e parte immaginaria *im*. *im* "
"predefinito a zero."

#: library/stdtypes.rst:1202 library/stdtypes.rst:3674
msgid "\\(6)"
msgstr "\\(6)"

#: library/stdtypes.rst:302
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: library/stdtypes.rst:306
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: library/stdtypes.rst:306
msgid "conjugate of the complex number *c*"
msgstr "coniugato del numero complesso *c*"

#: library/stdtypes.rst:309
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: library/stdtypes.rst:309
msgid "the pair ``(x // y, x % y)``"
msgstr "la coppia ``(x // y, x % y)``"

#: library/stdtypes.rst:309
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: library/stdtypes.rst:311
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: library/stdtypes.rst:313
msgid "*x* to the power *y*"
msgstr "*x* elevato alla potenza *y*"

#: library/stdtypes.rst:313 library/stdtypes.rst:1194 library/stdtypes.rst:2455
#: library/stdtypes.rst:3670 library/stdtypes.rst:3677
msgid "\\(5)"
msgstr "\\(5)"

#: library/stdtypes.rst:311
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: library/stdtypes.rst:313
msgid "``x ** y``"
msgstr "``x ** y``"

#: library/stdtypes.rst:323
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Anche chiamato divisione intera. Per operandi di tipo :class:`int`, il "
"risultato ha tipo :class:`int`. Per operandi di tipo :class:`float`, il "
"risultato ha tipo :class:`float`. In generale, il risultato è un numero "
"intero, anche se il tipo del risultato non è necessariamente :class:`int`. "
"Il risultato è sempre arrotondato verso meno infinito: ``1//2`` è ``0``, "
"``(-1)//2`` è ``-1``, ``1//(-2)`` è ``-1``, e ``(-1)//(-2)`` è ``0``."

#: library/stdtypes.rst:331
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Non per numeri complessi. Convertire invece a float usando :func:`abs` se "
"appropriato."

#: library/stdtypes.rst:342
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"La conversione da :class:`float` a :class:`int` tronca, scartando la parte "
"frazionaria. Vedere le funzioni :func:`math.floor` e :func:`math.ceil` per "
"conversioni alternative."

#: library/stdtypes.rst:347
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float accetta anche le stringhe \"nan\" e \"inf\" con un prefisso opzionale "
"\"+\" o \"-\" per Not a Number (NaN) e infinito positivo o negativo."

#: library/stdtypes.rst:351
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python definisce ``pow(0, 0)`` e ``0 ** 0`` come ``1``, come è comune nei "
"linguaggi di programmazione."

#: library/stdtypes.rst:355
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"I letterali numerici accettati includono le cifre ``0`` a ``9`` o qualsiasi "
"equivalente Unicode (punti di codice con la proprietà ``Nd``)."

#: library/stdtypes.rst:358
msgid ""
"See `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ for a complete list of code points with the ``Nd`` "
"property."
msgstr ""
"Vedere `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ per un elenco completo dei punti di codice con la "
"proprietà ``Nd``."

#: library/stdtypes.rst:362
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Tutti i tipi :class:`numbers.Real` (:class:`int` e :class:`float`) includono "
"anche le seguenti operazioni:"

#: library/stdtypes.rst:368
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: library/stdtypes.rst:368
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* troncato a :class:`~numbers.Integral`"

#: library/stdtypes.rst:371
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: library/stdtypes.rst:371
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* arrotondato a *n* cifre, arrotondando per eccesso in caso di mezza "
"unità. Se *n* è omesso, il valore predefinito è 0."

#: library/stdtypes.rst:375
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: library/stdtypes.rst:375
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "il più grande :class:`~numbers.Integral` <= *x*"

#: library/stdtypes.rst:378
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: library/stdtypes.rst:378
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "il più piccolo :class:`~numbers.Integral` >= *x*"

#: library/stdtypes.rst:382
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Per ulteriori operazioni numeriche vedere i moduli :mod:`math` e :mod:"
"`cmath`."

#: library/stdtypes.rst:391
msgid "Bitwise Operations on Integer Types"
msgstr "Operazioni Bitwise sui Tipi Integer"

#: library/stdtypes.rst:405
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Le operazioni bitwise hanno senso solo per gli interi. Il risultato delle "
"operazioni bitwise è calcolato come se eseguito in complemento a due con un "
"numero infinito di bit di segno."

#: library/stdtypes.rst:409
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Le priorità delle operazioni binarie bitwise sono tutte inferiori alle "
"operazioni numeriche e superiori alle comparazioni; l'operazione unaria "
"``~`` ha la stessa priorità delle altre operazioni numeriche unarie (``+`` e "
"``-``)."

#: library/stdtypes.rst:413
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Questa tabella elenca le operazioni bitwise ordinate per priorità crescente:"

#: library/stdtypes.rst:418
msgid "``x | y``"
msgstr "``x | y``"

#: library/stdtypes.rst:418
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "bitwise :dfn:`or` di *x* e *y*"

#: library/stdtypes.rst:421 library/stdtypes.rst:1215 library/stdtypes.rst:2445
#: library/stdtypes.rst:3663
msgid "\\(4)"
msgstr "\\(4)"

#: library/stdtypes.rst:421
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: library/stdtypes.rst:421
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "bitwise :dfn:`or esclusivo` di *x* e *y*"

#: library/stdtypes.rst:424
msgid "``x & y``"
msgstr "``x & y``"

#: library/stdtypes.rst:424
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "bitwise :dfn:`and` di *x* e *y*"

#: library/stdtypes.rst:427
msgid "``x << n``"
msgstr "``x << n``"

#: library/stdtypes.rst:427
msgid "*x* shifted left by *n* bits"
msgstr "*x* spostato a sinistra di *n* bit"

#: library/stdtypes.rst:427
msgid "(1)(2)"
msgstr "(1)(2)"

#: library/stdtypes.rst:429
msgid "``x >> n``"
msgstr "``x >> n``"

#: library/stdtypes.rst:429
msgid "*x* shifted right by *n* bits"
msgstr "*x* spostato a destra di *n* bit"

#: library/stdtypes.rst:429
msgid "(1)(3)"
msgstr "(1)(3)"

#: library/stdtypes.rst:431
msgid "``~x``"
msgstr "``~x``"

#: library/stdtypes.rst:431
msgid "the bits of *x* inverted"
msgstr "i bit di *x* invertiti"

#: library/stdtypes.rst:437
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"I conteggi di shift negativi sono illegali e causano un'eccezione :exc:"
"`ValueError`."

#: library/stdtypes.rst:440
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr ""
"Uno shift a sinistra di *n* bit è equivalente alla moltiplicazione per "
"``pow(2, n)``."

#: library/stdtypes.rst:443
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"Uno shift a destra di *n* bit è equivalente alla divisione intera per "
"``pow(2, n)``."

#: library/stdtypes.rst:446
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Eseguire questi calcoli con almeno un bit di estensione del segno in più in "
"una rappresentazione a complemento a due finita (una larghezza di bit "
"lavorativa di ``1 + max(x.bit_length(), y.bit_length())`` o più) è "
"sufficiente per ottenere lo stesso risultato come se ci fossero un numero "
"infinito di bit di segno."

#: library/stdtypes.rst:453
msgid "Additional Methods on Integer Types"
msgstr "Metodi Aggiuntivi sui Tipi Integer"

#: library/stdtypes.rst:455
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Il tipo int implementa la :class:`numbers.Integral` :term:`abstract base "
"class`. Inoltre, fornisce qualche metodo in più:"

#: library/stdtypes.rst:460
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Restituisce il numero di bit necessari a rappresentare un intero in binario, "
"escludendo il segno e gli zeri iniziali::"

#: library/stdtypes.rst:469
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Più precisamente, se ``x`` è diverso da zero, allora ``x.bit_length()`` è "
"l'unico intero positivo ``k`` tale che ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalentemente, quando ``abs(x)`` è sufficientemente piccolo da avere un "
"logaritmo correttamente arrotondato, allora ``k = 1 + int(log(abs(x), 2))``. "
"Se ``x`` è zero, allora ``x.bit_length()`` restituisce ``0``."

#: library/stdtypes.rst:498 library/stdtypes.rst:587
msgid "Equivalent to::"
msgstr "Equivalente a::"

#: library/stdtypes.rst:486
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Restituisce il numero di uno nella rappresentazione binaria del valore "
"assoluto dell’intero. Questo è anche conosciuto come il conteggio della "
"popolazione. Esempio::"

#: library/stdtypes.rst:507
msgid "Return an array of bytes representing an integer."
msgstr "Restituisce un array di byte che rappresenta un intero."

#: library/stdtypes.rst:519
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""
"L'intero è rappresentato utilizzando *length* byte, e il valore predefinito "
"è 1. Viene sollevata un'eccezione :exc:`OverflowError` se l'intero non è "
"rappresentabile con il numero di byte fornito."

#: library/stdtypes.rst:523
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"L'argomento *byteorder* determina l'ordine dei byte utilizzato per "
"rappresentare l'intero, e il valore predefinito è ``\"big\"``. Se "
"*byteorder* è ``\"big\"``, il byte più significativo è all'inizio dell'array "
"di byte. Se *byteorder* è ``\"little\"``, il byte più significativo è alla "
"fine dell'array di byte."

#: library/stdtypes.rst:529
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"L'argomento *signed* determina se viene utilizzato il complemento a due per "
"rappresentare l'intero. Se *signed* è ``False`` e viene fornito un intero "
"negativo, viene sollevata un'eccezione :exc:`OverflowError`. Il valore "
"predefinito di *signed* è ``False``."

#: library/stdtypes.rst:534
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr ""
"I valori predefiniti possono essere utilizzati per convertire comodamente un "
"intero in un singolo oggetto byte::"

#: library/stdtypes.rst:540
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr ""
"Tuttavia, quando si utilizzano gli argomenti predefiniti, non tentare di "
"convertire un valore maggiore di 255 o si otterrà un'eccezione :exc:"
"`OverflowError`."

#: library/stdtypes.rst:556
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr ""
"Aggiunti i valori predefiniti degli argomenti per ``length`` e ``byteorder``."

#: library/stdtypes.rst:561
msgid "Return the integer represented by the given array of bytes."
msgstr "Restituisce l'intero rappresentato dall'array di byte fornito."

#: library/stdtypes.rst:574
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"L'argomento *bytes* deve essere un :term:`bytes-like object` o un iterabile "
"che produce byte."

#: library/stdtypes.rst:577
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""
"L'argomento *byteorder* determina l'ordine dei byte utilizzato per "
"rappresentare l'intero, e il valore predefinito è ``\"big\"``. Se "
"*byteorder* è ``\"big\"``, il byte più significativo è all'inizio dell'array "
"di byte. Se *byteorder* è ``\"little\"``, il byte più significativo è alla "
"fine dell'array di byte. Per richiedere l'ordine dei byte nativo del sistema "
"host, utilizzare :data:`sys.byteorder` come valore dell'ordine dei byte."

#: library/stdtypes.rst:584
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"L'argomento *signed* indica se viene utilizzato il complemento a due per "
"rappresentare l'intero."

#: library/stdtypes.rst:604
msgid "Added default argument value for ``byteorder``."
msgstr "Aggiunto valore predefinito per l'argomento ``byteorder``."

#: library/stdtypes.rst:609
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and "
"has a positive denominator.  The integer ratio of integers (whole numbers) "
"is always the integer as the numerator and ``1`` as the denominator."
msgstr ""
"Restituisce una coppia di interi il cui rapporto è uguale all'intero "
"originale e ha un denominatore positivo. Il rapporto di numeri interi "
"(numeri interi) è sempre l'intero come numeratore e ``1`` come denominatore."

#: library/stdtypes.rst:618
msgid ""
"Returns ``True``. Exists for duck type compatibility with :meth:`float."
"is_integer`."
msgstr ""
"Restituisce ``True``. Esiste per compatibilità con il tipo anatropomorfico "
"con :meth:`float.is_integer`."

#: library/stdtypes.rst:623
msgid "Additional Methods on Float"
msgstr "Metodi aggiuntivi su Float"

#: library/stdtypes.rst:625
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Il tipo float implementa la classe :class:`numbers.Real` :term:`abstract "
"base class`. float ha anche i seguenti metodi aggiuntivi."

#: library/stdtypes.rst:630
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float. The ratio is in lowest terms and has a positive denominator.  Raises :"
"exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"Restituisce una coppia di interi il cui rapporto è esattamente uguale al "
"float originale. Il rapporto è in termini minimi e ha un denominatore "
"positivo. Solleva :exc:`OverflowError` su infiniti e una :exc:`ValueError` "
"su NaN."

#: library/stdtypes.rst:637
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Restituisce ``True`` se l'istanza float è finita con valore intero, e "
"``False`` altrimenti::"

#: library/stdtypes.rst:645
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Due metodi supportano la conversione da e verso stringhe esadecimali. Poiché "
"i float di Python sono memorizzati internamente come numeri binari, la "
"conversione di un float da o verso una stringa *decimale* di solito comporta "
"un piccolo errore di arrotondamento. Al contrario, le stringhe esadecimali "
"consentono una rappresentazione e specifica esatta dei numeri in virgola "
"mobile. Questo può essere utile durante il debugging e nel lavoro numerico."

#: library/stdtypes.rst:656
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Restituisce una rappresentazione di un numero in virgola mobile come una "
"stringa esadecimale. Per i numeri in virgola mobile finiti, questa "
"rappresentazione includerà sempre un ``0x`` iniziale e un ``p`` finale con "
"l'esponente."

#: library/stdtypes.rst:664
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Metodo di classe per restituire il float rappresentato da una stringa "
"esadecimale *s*. La stringa *s* può avere spazi bianchi iniziali e finali."

#: library/stdtypes.rst:669
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Nota che :meth:`float.hex` è un metodo di istanza, mentre :meth:`float."
"fromhex` è un metodo di classe."

#: library/stdtypes.rst:672
msgid "A hexadecimal string takes the form::"
msgstr "Una stringa esadecimale prende la forma::"

#: library/stdtypes.rst:676
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"dove il ``segno`` opzionale può essere ``+`` o ``-``, ``intero`` e "
"``frazione`` sono stringhe di cifre esadecimali, e l'``esponente`` è un "
"intero decimale con un segno iniziale opzionale. Il caso non è "
"significativo, e ci deve essere almeno una cifra esadecimale nell'intero o "
"nella frazione. Questa sintassi è simile a quella specificata nella sezione "
"6.4.4.2 dello standard C99, e anche a quella utilizzata in Java 1.5 in poi. "
"In particolare, l'output di :meth:`float.hex` può essere utilizzato come "
"letterale a virgola mobile esadecimale nel codice C o Java, e le stringhe "
"esadecimali prodotte dal carattere di formato ``%a`` di C o da ``Double."
"toHexString`` di Java sono accettate da :meth:`float.fromhex`."

#: library/stdtypes.rst:689
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Nota che l'esponente è scritto in decimale piuttosto che in esadecimale, e "
"che fornisce la potenza di 2 con cui moltiplicare il coefficiente. Ad "
"esempio, la stringa esadecimale ``0x3.a7p10`` rappresenta il numero in "
"virgola mobile ``(3 + 10./16 + 7./16**2) * 2.0**10``, o ``3740.0``::"

#: library/stdtypes.rst:699
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Applicando la conversione inversa a ``3740.0`` si ottiene una stringa "
"esadecimale diversa che rappresenta lo stesso numero::"

#: library/stdtypes.rst:709
msgid "Hashing of numeric types"
msgstr "Hashing dei tipi numerici"

#: library/stdtypes.rst:711
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`~sys.hash_info."
"modulus` attribute of :data:`sys.hash_info`."
msgstr ""
"Per i numeri ``x`` e ``y``, possibilmente di tipi diversi, è un requisito "
"che ``hash(x) == hash(y)`` ogni volta che ``x == y`` (vedi la documentazione "
"del metodo :meth:`~object.__hash__` per ulteriori dettagli). Per facilità di "
"implementazione e efficienza in una varietà di tipi numerici (inclusi :class:"
"`int`, :class:`float`, :class:`decimal.Decimal` e :class:`fractions."
"Fraction`) l'hash di Python per i tipi numerici si basa su una singola "
"funzione matematica definita per qualsiasi numero razionale, e quindi si "
"applica a tutte le istanze di :class:`int` e :class:`fractions.Fraction`, e "
"tutte le istanze finite di :class:`float` e :class:`decimal.Decimal`. "
"Essenzialmente, questa funzione è data dalla riduzione modulo ``P`` per un "
"primo fisso ``P``. Il valore di ``P`` è reso disponibile a Python come "
"l'attributo :attr:`~sys.hash_info.modulus` di :data:`sys.hash_info`."

#: library/stdtypes.rst:726
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Attualmente, il primo utilizzato è ``P = 2**31 - 1`` su macchine con long C "
"a 32 bit e ``P = 2**61 - 1`` su macchine con long C a 64 bit."

#: library/stdtypes.rst:729
msgid "Here are the rules in detail:"
msgstr "Ecco le regole in dettaglio:"

#: library/stdtypes.rst:731
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Se ``x = m / n`` è un numero razionale non negativo e ``n`` non è divisibile "
"per ``P``, definire ``hash(x)`` come ``m * invmod(n, P) % P``, dove "
"``invmod(n, P)`` fornisce l'inverso di ``n`` modulo ``P``."

#: library/stdtypes.rst:735
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Se ``x = m / n`` è un numero razionale non negativo e ``n`` è divisibile per "
"``P`` (ma ``m`` non lo è), allora ``n`` non ha inverso modulo ``P`` e la "
"regola sopra non si applica; in questo caso, definire ``hash(x)`` come il "
"valore costante ``sys.hash_info.inf``."

#: library/stdtypes.rst:740
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Se ``x = m / n`` è un numero razionale negativo, definire ``hash(x)`` come "
"``-hash(-x)``. Se l'hash risultante è ``-1``, sostituirlo con ``-2``."

#: library/stdtypes.rst:744
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"I valori particolari ``sys.hash_info.inf`` e ``-sys.hash_info.inf`` sono "
"utilizzati come valori hash per l'infinito positivo o negativo "
"(rispettivamente)."

#: library/stdtypes.rst:748
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Per un numero :class:`complex` ``z``, i valori hash delle parti reale e "
"immaginaria sono combinati calcolando ``hash(z.real) + sys.hash_info.imag * "
"hash(z.imag)``, ridotto modulo ``2**sys.hash_info.width`` in modo che "
"rientri in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``. Ancora una volta, se il risultato è ``-1``, viene sostituito con "
"``-2``."

#: library/stdtypes.rst:756
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Per chiarire le regole sopra, ecco un esempio di codice Python, equivalente "
"all'hash integrato, per calcolare l'hash di un numero razionale, :class:"
"`float` o :class:`complex`::"

#: library/stdtypes.rst:812
msgid "Boolean Type - :class:`bool`"
msgstr "Tipo Booleano - :class:`bool`"

#: library/stdtypes.rst:814
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two "
"constant instances: ``True`` and ``False``."
msgstr ""
"I booleani rappresentano valori di verità. Il tipo :class:`bool` ha "
"esattamente due istanze costanti: ``True`` e ``False``."

#: library/stdtypes.rst:822
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""
"La funzione integrata :func:`bool` converte qualsiasi valore in un booleano, "
"se il valore può essere interpretato come un valore di verità (vedi la "
"sezione :ref:`truth` sopra)."

#: library/stdtypes.rst:825
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` "
"to two booleans, they return a bool equivalent to the logical operations "
"\"and\", \"or\", \"xor\". However, the logical operators ``and``, ``or`` and "
"``!=`` should be preferred over ``&``, ``|`` and ``^``."
msgstr ""
"Per le operazioni logiche, utilizzare gli :ref:`operatori booleani "
"<boolean>` ``and``, ``or`` e ``not``. Quando si applicano gli operatori "
"bitwise ``&``, ``|``, ``^`` a due booleani, restituiscono un booleano "
"equivalente alle operazioni logiche \"and\", \"or\", \"xor\". Tuttavia, gli "
"operatori logici ``and``, ``or`` e ``!=`` dovrebbero essere preferiti a "
"``&``, ``|`` e ``^``."

#: library/stdtypes.rst:834
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise "
"an error in Python 3.14."
msgstr ""
"L'uso dell'operatore di inversione bitwise ``~`` è deprecato e genererà un "
"errore in Python 3.14."

#: library/stdtypes.rst:837
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In "
"many numeric contexts, ``False`` and ``True`` behave like the integers 0 and "
"1, respectively. However, relying on this is discouraged; explicitly convert "
"using :func:`int` instead."
msgstr ""
":class:`bool` è una sottoclasse di :class:`int` (vedi :ref:`typesnumeric`). "
"In molti contesti numerici, ``False`` e ``True`` si comportano come gli "
"interi 0 e 1, rispettivamente. Tuttavia, affidarsi a ciò è sconsigliato; "
"convertire esplicitamente utilizzando :func:`int`."

#: library/stdtypes.rst:845
msgid "Iterator Types"
msgstr "Tipi di Iteratore"

#: library/stdtypes.rst:853
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python supporta un concetto di iterazione sui contenitori. Questo è "
"implementato utilizzando due metodi distinti; questi sono utilizzati per "
"consentire alle classi definite dall'utente di supportare l'iterazione. Le "
"sequenze, descritte più dettagliatamente di seguito, supportano sempre i "
"metodi di iterazione."

#: library/stdtypes.rst:858
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"Un metodo deve essere definito per gli oggetti contenitore per fornire il "
"supporto :term:`iterable`:"

#: library/stdtypes.rst:865
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Restituisce un oggetto :term:`iterator`. È richiesto che l'oggetto supporti "
"il protocollo dell'iteratore descritto di seguito. Se un contenitore "
"supporta diversi tipi di iterazione, possono essere forniti ulteriori metodi "
"per richiedere specificamente iteratori per quei tipi di iterazione. (Un "
"esempio di oggetto che supporta più forme di iterazione potrebbe essere una "
"struttura ad albero che supporta sia l'attraversamento in ampiezza sia "
"quello in profondità.) Questo metodo corrisponde allo slot :c:member:"
"`~PyTypeObject.tp_iter` della struttura dei tipi per oggetti Python nell'API "
"Python/C."

#: library/stdtypes.rst:874
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Gli oggetti iteratore stessi devono supportare i seguenti due metodi, che "
"insieme formano il :dfn:`protocollo dell'iteratore`:"

#: library/stdtypes.rst:880
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Restituisce l'oggetto :term:`iterator` stesso. Questo è richiesto per "
"consentire sia ai contenitori che agli iteratori di essere utilizzati con le "
"dichiarazioni :keyword:`for` e :keyword:`in`. Questo metodo corrisponde allo "
"slot :c:member:`~PyTypeObject.tp_iter` della struttura dei tipi per oggetti "
"Python nell'API Python/C."

#: library/stdtypes.rst:889
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"Restituisce il prossimo elemento dall':term:`iterator`. Se non ci sono "
"ulteriori elementi, solleva l'eccezione :exc:`StopIteration`. Questo metodo "
"corrisponde allo slot :c:member:`~PyTypeObject.tp_iternext` della struttura "
"dei tipi per oggetti Python nell'API Python/C."

#: library/stdtypes.rst:894
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python definisce diversi oggetti iteratore per supportare l'iterazione su "
"tipi di sequenze generali e specifici, dizionari e altre forme più "
"specializzate. I tipi specifici non sono importanti oltre la loro "
"implementazione del protocollo dell'iteratore."

#: library/stdtypes.rst:899
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Una volta che il metodo :meth:`~iterator.__next__` di un iteratore solleva :"
"exc:`StopIteration`, deve continuare a farlo nelle chiamate successive. "
"Implementazioni che non rispettano questa proprietà sono considerate "
"difettose."

#: library/stdtypes.rst:907
msgid "Generator Types"
msgstr "Tipi di Generatore"

#: library/stdtypes.rst:909
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`~iterator.__iter__` "
"method is implemented as a generator, it will automatically return an "
"iterator object (technically, a generator object) supplying the :meth:`!"
"__iter__` and :meth:`~generator.__next__` methods. More information about "
"generators can be found in :ref:`the documentation for the yield expression "
"<yieldexpr>`."
msgstr ""
"I :term:`generator`\\i di Python forniscono un modo conveniente per "
"implementare il protocollo iterator. Se il metodo :meth:`~iterator.__iter__` "
"di un oggetto contenitore è implementato come un generatore, restituirà "
"automaticamente un oggetto iteratore (tecnicamente, un oggetto generatore) "
"che fornisce i metodi :meth:`!__iter__` e :meth:`~generator.__next__`. "
"Maggiori informazioni sui generatori si possono trovare nella :ref:"
"`documentazione sull'espressione yield <yieldexpr>`."

#: library/stdtypes.rst:921
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Tipi di Sequenza --- :class:`list`, :class:`tuple`, :class:`range`"

#: library/stdtypes.rst:923
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Esistono tre tipi di sequenza fondamentali: liste, tuple e oggetti range. "
"Ulteriori tipi di sequenza adatti per l'elaborazione di :ref:`dati binari "
"<binaryseq>` e :ref:`stringhe di testo <textseq>` sono descritti in sezioni "
"dedicate."

#: library/stdtypes.rst:932
msgid "Common Sequence Operations"
msgstr "Operazioni Comuni sulle Sequenze"

#: library/stdtypes.rst:936
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Le operazioni nella tabella seguente sono supportate dalla maggior parte dei "
"tipi di sequenza, sia mutabili che immutabili. La ABC :class:`collections."
"abc.Sequence` è fornita per facilitare l'implementazione corretta di queste "
"operazioni su tipi di sequenza personalizzati."

#: library/stdtypes.rst:941
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Questa tabella elenca le operazioni di sequenza ordinate in ordine crescente "
"di priorità. Nella tabella, *s* e *t* sono sequenze dello stesso tipo, *n*, "
"*i*, *j* e *k* sono interi e *x* è un oggetto arbitrario che soddisfa "
"eventuali restrizioni di tipo e valore imposte da *s*."

#: library/stdtypes.rst:946
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Le operazioni ``in`` e ``not in`` hanno le stesse priorità delle operazioni "
"di confronto. Le operazioni ``+`` (concatenazione) e ``*`` (ripetizione) "
"hanno la stessa priorità delle corrispondenti operazioni numeriche. [3]_"

#: library/stdtypes.rst:967
msgid "``x in s``"
msgstr "``x in s``"

#: library/stdtypes.rst:967
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` se un elemento di *s* è uguale a *x*, altrimenti ``False``"

#: library/stdtypes.rst:970
msgid "``x not in s``"
msgstr "``x not in s``"

#: library/stdtypes.rst:970
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` se un elemento di *s* è uguale a *x*, altrimenti ``True``"

#: library/stdtypes.rst:973
msgid "``s + t``"
msgstr "``s + t``"

#: library/stdtypes.rst:973
msgid "the concatenation of *s* and *t*"
msgstr "la concatenazione di *s* e *t*"

#: library/stdtypes.rst:973
msgid "(6)(7)"
msgstr "(6)(7)"

#: library/stdtypes.rst:976
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` o ``n * s``"

#: library/stdtypes.rst:976
msgid "equivalent to adding *s* to itself *n* times"
msgstr "equivalente ad aggiungere *s* a se stesso *n* volte"

#: library/stdtypes.rst:976
msgid "(2)(7)"
msgstr "(2)(7)"

#: library/stdtypes.rst:979
msgid "``s[i]``"
msgstr "``s[i]``"

#: library/stdtypes.rst:979
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*-esimo elemento di *s*, origine 0"

#: library/stdtypes.rst:981
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: library/stdtypes.rst:981
msgid "slice of *s* from *i* to *j*"
msgstr "fetta di *s* da *i* a *j*"

#: library/stdtypes.rst:981
msgid "(3)(4)"
msgstr "(3)(4)"

#: library/stdtypes.rst:983
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: library/stdtypes.rst:983
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "fetta di *s* da *i* a *j* con passo *k*"

#: library/stdtypes.rst:983
msgid "(3)(5)"
msgstr "(3)(5)"

#: library/stdtypes.rst:986
msgid "``len(s)``"
msgstr "``len(s)``"

#: library/stdtypes.rst:986
msgid "length of *s*"
msgstr "lunghezza di *s*"

#: library/stdtypes.rst:988
msgid "``min(s)``"
msgstr "``min(s)``"

#: library/stdtypes.rst:988
msgid "smallest item of *s*"
msgstr "l'elemento più piccolo di *s*"

#: library/stdtypes.rst:990
msgid "``max(s)``"
msgstr "``max(s)``"

#: library/stdtypes.rst:990
msgid "largest item of *s*"
msgstr "l'elemento più grande di *s*"

#: library/stdtypes.rst:992
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: library/stdtypes.rst:992
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"indice della prima occorrenza di *x* in *s* (a partire dall'indice *i* e "
"prima dell'indice *j*)"

#: library/stdtypes.rst:3645
msgid "\\(8)"
msgstr "\\(8)"

#: library/stdtypes.rst:996
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: library/stdtypes.rst:996
msgid "total number of occurrences of *x* in *s*"
msgstr "numero totale delle occorrenze di *x* in *s*"

#: library/stdtypes.rst:1000
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Sequenze dello stesso tipo supportano anche confronti. In particolare, tuple "
"e liste sono confrontate lessicograficamente confrontando gli elementi "
"corrispondenti. Questo significa che per risultare uguali, ogni elemento "
"deve risultare uguale e le due sequenze devono essere dello stesso tipo e "
"avere la stessa lunghezza. (Per i dettagli completi, vedere :ref:"
"`comparisons` nella documentazione del linguaggio.)"

#: library/stdtypes.rst:1010
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"Gli iteratori avanti e indietro su sequenze mutabili accedono ai valori "
"usando un indice. Questo indice continuerà ad avanzare (o retrocedere) anche "
"se la sequenza sottostante viene mutata. L'iteratore termina solo quando "
"viene trovata un'eccezione :exc:`IndexError` o :exc:`StopIteration` (o "
"quando l'indice scende sotto zero)."

#: library/stdtypes.rst:1019
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Anche se le operazioni ``in`` e ``not in`` sono usate solo per testare la "
"semplice appartenenza nel caso generale, alcune sequenze specializzate "
"(come :class:`str`, :class:`bytes` e :class:`bytearray`) le usano anche per "
"il test di sotto-sequenza::"

#: library/stdtypes.rst:1028
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"I valori di *n* inferiori a ``0`` sono trattati come ``0`` (il che produce "
"una sequenza vuota dello stesso tipo di *s*). Nota che gli elementi nella "
"sequenza *s* non vengono copiati; sono referenziati più volte. Questo spesso "
"confonde i nuovi programmatori Python; considera::"

#: library/stdtypes.rst:1040
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Quello che è successo è che ``[[]]`` è una lista a un solo elemento "
"contenente una lista vuota, quindi tutti e tre gli elementi di ``[[]] * 3`` "
"sono riferimenti a questa singola lista vuota. Modificare uno qualsiasi "
"degli elementi di ``lists`` modifica questa singola lista. Puoi creare una "
"lista di liste diverse in questo modo::"

#: library/stdtypes.rst:1052
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Ulteriori spiegazioni sono disponibili nella voce delle FAQ :ref:`faq-"
"multidimensional-list`."

#: library/stdtypes.rst:1056
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Se *i* o *j* è negativo, l'indice è relativo alla fine della sequenza *s*: "
"viene sostituito da ``len(s) + i`` o ``len(s) + j``. Ma nota che ``-0`` è "
"ancora ``0``."

#: library/stdtypes.rst:1061
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"La fetta di *s* da *i* a *j* è definita come la sequenza degli elementi con "
"indice *k* tale che ``i <= k < j``. Se *i* o *j* è maggiore di ``len(s)``, "
"viene usato ``len(s)``. Se *i* è omesso o ``None``, viene usato ``0``. Se "
"*j* è omesso o ``None``, viene usato ``len(s)``. Se *i* è maggiore o uguale "
"a *j*, la fetta è vuota."

#: library/stdtypes.rst:1068
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"La fetta di *s* da *i* a *j* con passo *k* è definita come la sequenza degli "
"elementi con indice ``x = i + n*k`` tale che ``0 <= n < (j-i)/k``. In altre "
"parole, gli indici sono ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` e così via, "
"fermandosi quando si raggiunge *j* (ma senza includere *j*). Quando *k* è "
"positivo, *i* e *j* sono ridotti a ``len(s)`` se sono maggiori. Quando *k* è "
"negativo, *i* e *j* sono ridotti a ``len(s) - 1`` se sono maggiori. Se *i* o "
"*j* sono omessi o ``None``, diventano valori \"finali\" (quale finale "
"dipende dal segno di *k*). Nota, *k* non può essere zero. Se *k* è ``None``, "
"viene trattato come ``1``."

#: library/stdtypes.rst:1079
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"La concatenazione di sequenze immutabili produce sempre un nuovo oggetto. "
"Questo significa che costruire una sequenza concatenando ripetutamente avrà "
"un costo di runtime quadratico in relazione alla lunghezza totale della "
"sequenza. Per ottenere un costo di runtime lineare, è necessario passare a "
"una delle alternative seguenti:"

#: library/stdtypes.rst:1084
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"se stai concatenando oggetti :class:`str`, puoi costruire una lista e usare :"
"meth:`str.join` alla fine oppure scrivere a un'istanza di :class:`io."
"StringIO` e recuperare il suo valore al termine"

#: library/stdtypes.rst:1088
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"se stai concatenando oggetti :class:`bytes`, puoi allo stesso modo usare :"
"meth:`bytes.join` o :class:`io.BytesIO`, oppure puoi fare una concatenazione "
"in loco con un oggetto :class:`bytearray`. Gli oggetti :class:`bytearray` "
"sono mutabili e hanno un meccanismo di sovra-allocazione efficiente"

#: library/stdtypes.rst:1093
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"se concatenare oggetti :class:`tuple`, estendere una :class:`list` invece"

#: library/stdtypes.rst:1095
msgid "for other types, investigate the relevant class documentation"
msgstr "per altri tipi, consultare la documentazione della classe pertinente"

#: library/stdtypes.rst:1099
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Alcuni tipi di sequenze (come :class:`range`) supportano solo sequenze di "
"elementi che seguono schemi specifici, e quindi non supportano la "
"concatenazione o la ripetizione della sequenza."

#: library/stdtypes.rst:1104
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``index`` solleva :exc:`ValueError` quando *x* non è trovato in *s*. Non "
"tutte le implementazioni supportano il passaggio degli argomenti aggiuntivi "
"*i* e *j*. Questi argomenti permettono una ricerca efficiente di "
"sottosezioni della sequenza. Passare gli argomenti extra è grosso modo "
"equivalente a usare ``s[i:j].index(x)``, solo senza copiare alcun dato e con "
"l'indice restituito relativo all'inizio della sequenza piuttosto che "
"all'inizio del sottoinsieme."

#: library/stdtypes.rst:1115
msgid "Immutable Sequence Types"
msgstr "Tipi di Sequenza Immutabili"

#: library/stdtypes.rst:1122
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"L'unica operazione che i tipi di sequenza immutabili generalmente "
"implementano che non è implementata anche dai tipi di sequenza mutabili è il "
"supporto per la funzione built-in :func:`hash`."

#: library/stdtypes.rst:1126
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Questo supporto consente alle sequenze immutabili, come le istanze di :class:"
"`tuple`, di essere utilizzate come chiavi di :class:`dict` e memorizzate in "
"istanze di :class:`set` e :class:`frozenset`."

#: library/stdtypes.rst:1130
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Tentare di fare l'hash di una sequenza immutabile che contiene valori non "
"hashabili risulterà in un :exc:`TypeError`."

#: library/stdtypes.rst:1137
msgid "Mutable Sequence Types"
msgstr "Tipi di Sequenza Mutabili"

#: library/stdtypes.rst:1144
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Le operazioni nella tabella seguente sono definite sui tipi di sequenza "
"mutabili. L'ABC :class:`collections.abc.MutableSequence` è fornito per "
"rendere più facile implementare correttamente queste operazioni su tipi di "
"sequenza personalizzati."

#: library/stdtypes.rst:1148
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"Nella tabella, *s* è un'istanza di un tipo di sequenza mutabile, *t* è un "
"qualsiasi oggetto iterabile e *x* è un oggetto arbitrario che soddisfa "
"qualsiasi restrizione di tipo e valore imposta da *s* (ad esempio, :class:"
"`bytearray` accetta solo interi che soddisfano la restrizione di valore ``0 "
"<= x <= 255``)."

#: library/stdtypes.rst:1172
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: library/stdtypes.rst:1172
msgid "item *i* of *s* is replaced by *x*"
msgstr "l'elemento *i* di *s* è sostituito da *x*"

#: library/stdtypes.rst:1175
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: library/stdtypes.rst:1175
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"il sottoinsieme di *s* da *i* a *j* è sostituito dal contenuto "
"dell'iterabile *t*"

#: library/stdtypes.rst:1179
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: library/stdtypes.rst:1179
msgid "same as ``s[i:j] = []``"
msgstr "come ``s[i:j] = []``"

#: library/stdtypes.rst:1181
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: library/stdtypes.rst:1181
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "gli elementi di ``s[i:j:k]`` sono sostituiti da quelli di *t*"

#: library/stdtypes.rst:1184
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: library/stdtypes.rst:1184
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "rimuove gli elementi di ``s[i:j:k]`` dalla lista"

#: library/stdtypes.rst:1187
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: library/stdtypes.rst:1187
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"aggiunge *x* alla fine della sequenza (come ``s[len(s):len(s)] = [x]``)"

#: library/stdtypes.rst:1191
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: library/stdtypes.rst:1191
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "rimuove tutti gli elementi da *s* (come ``del s[:]``)"

#: library/stdtypes.rst:1194
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: library/stdtypes.rst:1194
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "crea una copia superficiale di *s* (come ``s[:]``)"

#: library/stdtypes.rst:1197
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` o ``s += t``"

#: library/stdtypes.rst:1197
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"estende *s* con il contenuto di *t* (per lo più come ``s[len(s):len(s)] = "
"t``)"

#: library/stdtypes.rst:1202
msgid "``s *= n``"
msgstr "``s *= n``"

#: library/stdtypes.rst:1202
msgid "updates *s* with its contents repeated *n* times"
msgstr "aggiorna *s* con il suo contenuto ripetuto *n* volte"

#: library/stdtypes.rst:1205
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: library/stdtypes.rst:1205
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr "inserisce *x* in *s* all'indice dato da *i* (come ``s[i:i] = [x]``)"

#: library/stdtypes.rst:1209
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` o ``s.pop(i)``"

#: library/stdtypes.rst:1209
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "recupera l'elemento a *i* e lo rimuove anche da *s*"

#: library/stdtypes.rst:1212
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: library/stdtypes.rst:1212
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "rimuove il primo elemento da *s* dove ``s[i]`` è uguale a *x*"

#: library/stdtypes.rst:1215
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: library/stdtypes.rst:1215
msgid "reverses the items of *s* in place"
msgstr "inverte gli elementi di *s* in loco"

#: library/stdtypes.rst:1223
msgid "*t* must have the same length as the slice it is replacing."
msgstr ""
"*t* deve avere la stessa lunghezza del sottoinsieme che sta sostituendo."

#: library/stdtypes.rst:1226
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"L'argomento opzionale *i* di default è ``-1``, in modo che per default "
"l'ultimo elemento sia rimosso e restituito."

#: library/stdtypes.rst:1230
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
":meth:`remove` solleva :exc:`ValueError` quando *x* non è trovato in *s*."

#: library/stdtypes.rst:1233
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"Il metodo :meth:`reverse` modifica la sequenza in loco per economia di "
"spazio quando si inverte una grande sequenza. Per ricordare agli utenti che "
"opera tramite effetti collaterali, non restituisce la sequenza invertita."

#: library/stdtypes.rst:1238
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`clear` e :meth:`!copy` sono inclusi per coerenza con le interfacce "
"dei contenitori mutabili che non supportano le operazioni di slicing (come :"
"class:`dict` e :class:`set`). :meth:`!copy` non fa parte dell'ABC :class:"
"`collections.abc.MutableSequence`, ma la maggior parte delle classi di "
"sequenze mutabili concrete lo forniscono."

#: library/stdtypes.rst:1244
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "Metodi :meth:`clear` e :meth:`!copy`."

#: library/stdtypes.rst:1248
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"Il valore *n* è un intero, o un oggetto che implementa :meth:`~object."
"__index__`. Valori zero e negativi di *n* svuotano la sequenza. Gli elementi "
"nella sequenza non sono copiati; sono referenziati più volte, come spiegato "
"per ``s * n`` sotto :ref:`typesseq-common`."

#: library/stdtypes.rst:1257
msgid "Lists"
msgstr "Liste"

#: library/stdtypes.rst:1261
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Le liste sono sequenze mutabili, tipicamente utilizzate per memorizzare "
"collezioni di elementi omogenei (dove il grado di somiglianza preciso varia "
"in base all'applicazione)."

#: library/stdtypes.rst:1267
msgid "Lists may be constructed in several ways:"
msgstr "Le liste possono essere costruite in diversi modi:"

#: library/stdtypes.rst:1269
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"Usare una coppia di parentesi quadre per denotare la lista vuota: ``[]``"

#: library/stdtypes.rst:1270
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Utilizzo delle parentesi quadre, separando gli elementi con virgole: "
"``[a]``, ``[a, b, c]``"

#: library/stdtypes.rst:1271
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Utilizzo di una lista comprensiva: ``[x for x in iterable]``"

#: library/stdtypes.rst:1272
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Utilizzo del costruttore del tipo: ``list()`` o ``list(iterable)``"

#: library/stdtypes.rst:1274
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Il costruttore costruisce una lista i cui elementi sono gli stessi e nello "
"stesso ordine degli elementi di *iterable*. *iterable* può essere una "
"sequenza, un contenitore che supporta l'iterazione, o un oggetto iteratore. "
"Se *iterable* è già una lista, viene fatta una copia e restituita, simile a "
"``iterable[:]``. Ad esempio, ``list('abc')`` restituisce ``['a', 'b', 'c']`` "
"e ``list( (1, 2, 3) )`` restituisce ``[1, 2, 3]``. Se non viene fornito "
"alcun argomento, il costruttore crea una nuova lista vuota, ``[]``."

#: library/stdtypes.rst:1283
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Molte altre operazioni producono anche liste, includendo la funzione built-"
"in :func:`sorted`."

#: library/stdtypes.rst:1286
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Le liste implementano tutte le operazioni comuni di sequenza: :ref:`common "
"<typesseq-common>` e modificabili: :ref:`mutable <typesseq-mutable>`. Le "
"liste forniscono anche il seguente metodo aggiuntivo:"

#: library/stdtypes.rst:1292
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Questo metodo ordina la lista sul posto, utilizzando solo i confronti ``<`` "
"tra gli elementi. Le eccezioni non vengono soppresse - se una qualsiasi "
"operazione di confronto fallisce, l'intera operazione di ordinamento fallirà "
"(e la lista sarà probabilmente lasciata in uno stato parzialmente "
"modificato)."

#: library/stdtypes.rst:1297
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` accetta due argomenti che possono essere passati solo tramite "
"parola chiave (:ref:`keyword-only arguments <keyword-only_parameter>`):"

#: library/stdtypes.rst:1300
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* specifica una funzione di un argomento che viene utilizzata per "
"estrarre una chiave di confronto da ciascun elemento della lista (ad "
"esempio, ``key=str.lower``). La chiave corrispondente a ciascun elemento "
"nella lista viene calcolata una volta e poi utilizzata per l'intero processo "
"di ordinamento. Il valore predefinito di ``None`` significa che gli elementi "
"della lista vengono ordinati direttamente senza calcolare un valore di "
"chiave separato."

#: library/stdtypes.rst:1307
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"L'utilità :func:`functools.cmp_to_key` è disponibile per convertire una "
"funzione *cmp* in stile 2.x in una funzione *key*."

#: library/stdtypes.rst:1310
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* è un valore booleano. Se impostato su ``True``, gli elementi della "
"lista vengono ordinati come se ogni confronto fosse invertito."

#: library/stdtypes.rst:1313
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Questo metodo modifica la sequenza in loco per risparmiare spazio quando si "
"ordina una grande sequenza. Per ricordare agli utenti che funziona con "
"effetti collaterali, non restituisce la sequenza ordinata (utilizzare :func:"
"`sorted` per richiedere esplicitamente una nuova istanza di lista ordinata)."

#: library/stdtypes.rst:1318
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"Il metodo :meth:`sort` è garantito per essere stabile. Un ordinamento è "
"stabile se garantisce di non cambiare l'ordine relativo degli elementi che "
"risultano uguali --- questo è utile per l'ordinamento in più passate (ad "
"esempio, ordinare per reparto, poi per grado salariale)."

#: library/stdtypes.rst:1323
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Per esempi di ordinamento e un breve tutorial sull'ordinamento, vedere :ref:"
"`sortinghowto`."

#: library/stdtypes.rst:1327
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Mentre una lista viene ordinata, l'effetto di tentare di modificarla o anche "
"solo ispezionarla è indefinito. L'implementazione C di Python fa apparire la "
"lista vuota per la durata, e solleva :exc:`ValueError` se riesce a rilevare "
"che la lista è stata modificata durante un ordinamento."

#: library/stdtypes.rst:1336
msgid "Tuples"
msgstr "Tuple"

#: library/stdtypes.rst:1340
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Le tuple sono sequenze immutabili, tipicamente utilizzate per memorizzare "
"collezioni di dati eterogenei (come le 2-tuple prodotte dalla funzione built-"
"in :func:`enumerate`). Le tuple sono utilizzate anche nei casi in cui è "
"necessaria una sequenza immutabile di dati omogenei (come permettere la "
"memorizzazione in un'istanza di :class:`set` o :class:`dict`)."

#: library/stdtypes.rst:1348
msgid "Tuples may be constructed in a number of ways:"
msgstr "Le tuple possono essere costruite in diversi modi:"

#: library/stdtypes.rst:1350
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"Utilizzando una coppia di parentesi per denotare la tupla vuota: ``()``"

#: library/stdtypes.rst:1351
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Utilizzando una virgola finale per una tupla singleton: ``a,`` o ``(a,)``"

#: library/stdtypes.rst:1352
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Separando gli elementi con virgole: ``a, b, c`` o ``(a, b, c)``"

#: library/stdtypes.rst:1353
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Utilizzando la funzione built-in :func:`tuple`: ``tuple()`` o "
"``tuple(iterable)``"

#: library/stdtypes.rst:1355
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Il costruttore costruisce una tupla i cui elementi sono gli stessi e nello "
"stesso ordine degli elementi di *iterable*. *iterable* può essere una "
"sequenza, un contenitore che supporta l'iterazione, o un oggetto iteratore. "
"Se *iterable* è già una tupla, viene restituita invariata. Ad esempio, "
"``tuple('abc')`` restituisce ``('a', 'b', 'c')`` e ``tuple( [1, 2, 3] )`` "
"restituisce ``(1, 2, 3)``. Se non viene fornito alcun argomento, il "
"costruttore crea una nuova tupla vuota, ``()``."

#: library/stdtypes.rst:1363
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Nota che in realtà è la virgola che crea una tupla, non le parentesi. Le "
"parentesi sono facoltative, tranne nel caso della tupla vuota, o quando sono "
"necessarie per evitare ambiguità sintattiche. Ad esempio, ``f(a, b, c)`` è "
"una chiamata a funzione con tre argomenti, mentre ``f((a, b, c))`` è una "
"chiamata a funzione con una 3-tuple come unico argomento."

#: library/stdtypes.rst:1369
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Le tuple implementano tutte le operazioni di sequenza comuni: :ref:`common "
"<typesseq-common>`."

#: library/stdtypes.rst:1372
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Per collezioni eterogenee di dati dove l'accesso per nome è più chiaro che "
"l'accesso per indice, :func:`collections.namedtuple` può essere una scelta "
"più appropriata di un semplice oggetto tupla."

#: library/stdtypes.rst:1380
msgid "Ranges"
msgstr "Intervalli"

#: library/stdtypes.rst:1384
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Il tipo :class:`range` rappresenta una sequenza immutabile di numeri ed è "
"comunemente utilizzato per iterare un numero specifico di volte nei cicli :"
"keyword:`for`."

#: library/stdtypes.rst:1391
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Gli argomenti al costruttore di range devono essere interi (sia la classe "
"built-in :class:`int` o qualsiasi oggetto che implementa il metodo speciale :"
"meth:`~object.__index__`). Se l'argomento *step* è omesso, il valore "
"predefinito è ``1``. Se l'argomento *start* è omesso, il valore predefinito "
"è ``0``. Se *step* è zero, viene sollevata l'eccezione :exc:`ValueError`."

#: library/stdtypes.rst:1397
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Per un *step* positivo, il contenuto di un intervallo ``r`` è determinato "
"dalla formula ``r[i] = start + step*i`` dove ``i >= 0`` e ``r[i] < stop``."

#: library/stdtypes.rst:1401
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Per un *step* negativo, il contenuto dell'intervallo è ancora determinato "
"dalla formula ``r[i] = start + step*i``, ma i vincoli sono ``i >= 0`` e "
"``r[i] > stop``."

#: library/stdtypes.rst:1405
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Un oggetto range sarà vuoto se ``r[0]`` non soddisfa il vincolo di valore. "
"Gli intervalli supportano indici negativi, ma questi sono interpretati come "
"indice dalla fine della sequenza determinata dagli indici positivi."

#: library/stdtypes.rst:1410
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Gli intervalli contenenti valori assoluti maggiori di :data:`sys.maxsize` "
"sono permessi, ma alcune funzionalità (come :func:`len`) potrebbero "
"sollevare l'eccezione :exc:`OverflowError`."

#: library/stdtypes.rst:1414
msgid "Range examples::"
msgstr "Esempi di intervalli::"

#: library/stdtypes.rst:1431
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Gli intervalli implementano tutte le operazioni di sequenza comuni: :ref:"
"`common <typesseq-common>`, eccezion fatta per la concatenazione e la "
"ripetizione (a causa del fatto che gli oggetti range possono rappresentare "
"solo sequenze che seguono un modello rigoroso e la ripetizione e la "
"concatenazione violerebbero di solito tale modello)."

#: library/stdtypes.rst:1438
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""
"Il valore del parametro *start* (o ``0`` se il parametro non è stato fornito)"

#: library/stdtypes.rst:1443
msgid "The value of the *stop* parameter"
msgstr "Il valore del parametro *stop*"

#: library/stdtypes.rst:1447
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""
"Il valore del parametro *step* (o ``1`` se il parametro non è stato fornito)"

#: library/stdtypes.rst:1450
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"Il vantaggio del tipo :class:`range` rispetto a una lista regolare :class:"
"`list` o una tupla :class:`tuple` è che un oggetto :class:`range` utilizzerà "
"sempre la stessa (piccola) quantità di memoria, indipendentemente dalla "
"dimensione dell'intervallo che rappresenta (poiché memorizza solo i valori "
"``start``, ``stop`` e ``step``, calcolando gli elementi individuali e i "
"sottointervalli secondo necessità)."

#: library/stdtypes.rst:1456
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Gli oggetti range implementano l'ABC :class:`collections.abc.Sequence`, e "
"forniscono funzionalità come test di inclusione, ricerca dell'indice degli "
"elementi, slicing e supporto per indici negativi (vedi :ref:`typesseq`):"

#: library/stdtypes.rst:1476
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Testare gli oggetti range per uguaglianza con ``==`` e ``!=`` li confronta "
"come sequenze. Cioè, due oggetti range sono considerati uguali se "
"rappresentano la stessa sequenza di valori. (Nota che due oggetti range che "
"risultano uguali potrebbero avere attributi :attr:`~range.start`, :attr:"
"`~range.stop` e :attr:`~range.step` diversi, ad esempio ``range(0) == "
"range(2, 1, 3)`` oppure ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: library/stdtypes.rst:1483
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Implementare l'ABC Sequence. Supporto per slicing e indici negativi. Testare "
"gli oggetti :class:`int` per la membership in tempo costante invece di "
"iterare attraverso tutti gli elementi."

#: library/stdtypes.rst:1489
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Definire '==' e '!=' per confrontare gli oggetti range basandosi sulla "
"sequenza di valori che definiscono (invece di confrontare basandosi "
"sull'identità degli oggetti)."

#: library/stdtypes.rst:1494
msgid ""
"Added the :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Aggiunti gli attributi :attr:`~range.start`, :attr:`~range.stop` e :attr:"
"`~range.step`."

#: library/stdtypes.rst:1499
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ shows how to implement a lazy version of range "
"suitable for floating point applications."
msgstr ""
"La `ricetta linspace <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ mostra come implementare una versione lazy di "
"range adatta per applicazioni con numeri in virgola mobile."

#: library/stdtypes.rst:1511
msgid "Text Sequence Type --- :class:`str`"
msgstr "Tipo Sequenza di Testo --- :class:`str`"

#: library/stdtypes.rst:1513
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"I dati testuali in Python sono gestiti con oggetti :class:`str`, o :dfn:"
"`string`. Le stringhe sono :ref:`sequenze <typesseq>` immutabili di punti di "
"codice Unicode. I letterali stringa possono essere scritti in vari modi:"

#: library/stdtypes.rst:1518
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Apici singoli: ``'allows embedded \"double\" quotes'``"

#: library/stdtypes.rst:1519
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Apici doppi: ``\"allows embedded 'single' quotes\"``"

#: library/stdtypes.rst:1520
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Apici tripli: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"

#: library/stdtypes.rst:1522
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Le stringhe con tripla virgoletta possono estendersi su più righe - tutti "
"gli spazi bianchi associati saranno inclusi nel letterale della stringa."

#: library/stdtypes.rst:1525
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"I letterali di stringa che fanno parte di una singola espressione e "
"contengono solo spazi bianchi tra di loro saranno convertiti implicitamente "
"in un singolo letterale di stringa. Cioè, ``(\"spam \" \"eggs\") == \"spam "
"eggs\"``."

#: library/stdtypes.rst:1529
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported :ref:`escape sequences <escape-sequences>`, and the "
"``r`` (\"raw\") prefix that disables most escape sequence processing."
msgstr ""
"Vedi :ref:`strings` per ulteriori dettagli sulle varie forme di letterali di "
"stringa, comprese le :ref:`sequenze di escape <escape-sequences>` "
"supportate, e il prefisso ``r`` (\"raw\") che disabilita la maggior parte "
"delle elaborazioni delle sequenze di escape."

#: library/stdtypes.rst:1533
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Le stringhe possono anche essere create da altri oggetti utilizzando il "
"costruttore :class:`str`."

#: library/stdtypes.rst:1536
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Poiché non esiste un tipo \"carattere\" separato, l'indicizzazione di una "
"stringa produce stringhe di lunghezza 1. Cioè, per una stringa non vuota "
"*s*, ``s[0] == s[0:1]``."

#: library/stdtypes.rst:1542
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Inoltre, non esiste un tipo di stringa mutabile, ma :meth:`str.join` o :"
"class:`io.StringIO` possono essere usati per costruire efficientemente "
"stringhe da più frammenti."

#: library/stdtypes.rst:1546
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Per retrocompatibilità con la serie Python 2, il prefisso ``u`` è nuovamente "
"permesso sui letterali di stringa. Non ha effetto sul significato dei "
"letterali di stringa e non può essere combinato con il prefisso ``r``."

#: library/stdtypes.rst:1558
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Restituisce una versione :ref:`stringa <textseq>` di *object*. Se *object* "
"non viene fornito, restituisce la stringa vuota. Altrimenti, il "
"comportamento di ``str()`` dipende dalla presenza di *encoding* o *errors*, "
"come segue."

#: library/stdtypes.rst:1562
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :func:"
"`repr(object) <repr>`."
msgstr ""
"Se né *encoding* né *errors* vengono forniti, ``str(object)`` restituisce :"
"meth:`type(object).__str__(object) <object.__str__>` che è la "
"rappresentazione \"informale\" o ben stampabile di *object*. Per gli oggetti "
"stringa, questa è la stringa stessa. Se *object* non ha un metodo :meth:"
"`~object.__str__`, allora :func:`str` ricorre alla restituzione di :func:"
"`repr(object) <repr>`."

#: library/stdtypes.rst:1574
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Se viene fornito almeno uno tra *encoding* o *errors*, *object* dovrebbe "
"essere un :term:`bytes-like object` (ad es. :class:`bytes` o :class:"
"`bytearray`). In questo caso, se *object* è un oggetto :class:`bytes` (o :"
"class:`bytearray`), allora ``str(bytes, encoding, errors)`` è equivalente a :"
"meth:`bytes.decode(encoding, errors) <bytes.decode>`. Altrimenti, l'oggetto "
"bytes sottostante l'oggetto buffer viene ottenuto prima di chiamare :meth:"
"`bytes.decode`. Vedi :ref:`binaryseq` e :ref:`bufferobjects` per "
"informazioni sugli oggetti buffer."

#: library/stdtypes.rst:1583
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Passare un oggetto :class:`bytes` a :func:`str` senza argomenti *encoding* o "
"*errors* rientra nel primo caso che restituisce la rappresentazione "
"informale della stringa (vedi anche l'opzione della riga di comando :option:"
"`-b` di Python). Per esempio::"

#: library/stdtypes.rst:1591
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Per maggiori informazioni sulla classe ``str`` e i suoi metodi, vedere :ref:"
"`textseq` e la sezione :ref:`string-methods` qui sotto. Per generare "
"stringhe formattate, vedere le sezioni :ref:`f-strings` e :ref:"
"`formatstrings`. Inoltre, vedere la sezione :ref:`stringservices`."

#: library/stdtypes.rst:1603
msgid "String Methods"
msgstr "Metodi per le Stringhe"

#: library/stdtypes.rst:1608
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Le stringhe implementano tutte le operazioni delle sequenze :ref:`comuni "
"<typesseq-common>`, insieme ai metodi aggiuntivi descritti di seguito."

#: library/stdtypes.rst:1611
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Le stringhe supportano anche due stili di formattazione delle stringhe, uno "
"che fornisce un alto grado di flessibilità e personalizzazione (vedi :meth:"
"`str.format`, :ref:`formatstrings` e :ref:`string-formatting`) e l'altro "
"basato sulla formattazione in stile C ``printf`` che gestisce una gamma più "
"ristretta di tipi ed è leggermente più difficile da usare correttamente, ma "
"è spesso più veloce nei casi che può gestire (:ref:`old-string-formatting`)."

#: library/stdtypes.rst:1618
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"La sezione :ref:`textservices` della libreria standard copre un certo numero "
"di altri moduli che forniscono vari utilità relative al testo (incluso il "
"supporto per le espressioni regolari nel modulo :mod:`re`)."

#: library/stdtypes.rst:1624
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Restituisce una copia della stringa con il primo carattere in maiuscolo e il "
"resto in minuscolo."

#: library/stdtypes.rst:1627
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"Il primo carattere è ora convertito in titlecase piuttosto che in maiuscolo. "
"Questo significa che caratteri come i digrammi avranno solo la prima lettera "
"maiuscola, invece del carattere completo."

#: library/stdtypes.rst:1634
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Restituisce una copia della stringa normalizzata in minuscolo. Le stringhe "
"normalizzate in minuscolo possono essere utilizzate per confronti senza "
"distinzione tra maiuscole e minuscole."

#: library/stdtypes.rst:1637
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"La normalizzazione in minuscolo è simile alla conversione in minuscolo ma "
"più aggressiva perché è pensata per rimuovere tutte le differenze di "
"maiuscolo e minuscolo in una stringa. Ad esempio, la lettera tedesca "
"minuscola ``'ß'`` è equivalente a ``\"ss\"``. Poiché è già minuscola, :meth:"
"`lower` non farebbe nulla per ``'ß'``; :meth:`casefold` la converte in "
"``\"ss\"``."

#: library/stdtypes.rst:1643
#, fuzzy
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""
"L'algoritmo di normalizzazione in minuscolo è `descritto nella sezione 3.13 "
"'Default Case Folding' dello Standard Unicode <https://www.unicode.org/"
"versions/Unicode15.1.0/ch03.pdf>`__."

#: library/stdtypes.rst:1652
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Restituisce la stringa centrata in una lunghezza di *width*. L'imbottitura è "
"fatta usando il *fillchar* specificato (il default è uno spazio ASCII). La "
"stringa originale viene restituita se *width* è minore o uguale a ``len(s)``."

#: library/stdtypes.rst:1660
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Restituisce il numero di occorrenze non sovrapposte della sottostringa *sub* "
"nell'intervallo [*start*, *end*]. Gli argomenti opzionali *start* e *end* "
"sono interpretati come nella notazione delle slice."

#: library/stdtypes.rst:1664
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr ""
"Se *sub* è vuoto, restituisce il numero di stringhe vuote tra i caratteri, "
"che è la lunghezza della stringa più uno."

#: library/stdtypes.rst:1670
msgid "Return the string encoded to :class:`bytes`."
msgstr "Restituisce la stringa codificata in :class:`bytes`."

#: library/stdtypes.rst:2811
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""
"*encoding* di default è ``'utf-8'``; vedere :ref:`standard-encodings` per i "
"valori possibili."

#: library/stdtypes.rst:1675
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* controlla come vengono gestiti gli errori di codifica. Se "
"``'strict'`` (il default), viene sollevata un'eccezione :exc:`UnicodeError`. "
"Altri valori possibili sono ``'ignore'``, ``'replace'``, "
"``'xmlcharrefreplace'``, ``'backslashreplace'`` e qualsiasi altro nome "
"registrato tramite :func:`codecs.register_error`. Vedi :ref:`error-handlers` "
"per dettagli."

#: library/stdtypes.rst:1682
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used."
msgstr ""
"Per motivi di prestazioni, il valore di *errors* non viene controllato per "
"validità a meno che non si verifichi effettivamente un errore di codifica, :"
"ref:`devmode` è abilitato o viene utilizzata una :ref:`build di debug <debug-"
"build>`."

#: library/stdtypes.rst:2830
msgid "Added support for keyword arguments."
msgstr "Aggiunto supporto per argomenti di tipo keyword."

#: library/stdtypes.rst:2833
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""
"Il valore dell'argomento *errors* ora viene controllato in :ref:`devmode` e "
"in :ref:`modalità di debug <debug-build>`."

#: library/stdtypes.rst:1697
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Restituisce ``True`` se la stringa termina con il *suffix* specificato, "
"altrimenti restituisce ``False``. *suffix* può anche essere una tupla di "
"suffixes da cercare. Con *start* opzionale, il test inizia dalla posizione "
"specificata. Con *end* opzionale, si interrompe il confronto in quella "
"posizione."

#: library/stdtypes.rst:1705
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Restituisce una copia della stringa in cui tutti i caratteri di tabulazione "
"sono sostituiti da uno o più spazi, a seconda della colonna corrente e della "
"dimensione della tabulazione specificata. Le posizioni delle tabulazioni si "
"verificano ogni *tabsize* caratteri (il default è 8, dando posizioni delle "
"tabulazioni alle colonne 0, 8, 16 e così via). Per espandere la stringa, la "
"colonna corrente viene impostata a zero e la stringa viene esaminata "
"carattere per carattere. Se il carattere è una tabulazione (``\\t``), uno o "
"più caratteri di spazio vengono inseriti nel risultato fino a quando la "
"colonna corrente è uguale alla successiva posizione di tabulazione. (Il "
"carattere di tabulazione stesso non viene copiato.) Se il carattere è una "
"nuova linea (``\\n``) o ritorno a capo (``\\r``), viene copiato e la colonna "
"corrente viene reimpostata a zero. Qualsiasi altro carattere viene copiato "
"senza modifiche e la colonna corrente viene incrementata di uno "
"indipendentemente da come viene rappresentato il carattere quando stampato."

#: library/stdtypes.rst:1726
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Restituisce l'indice più basso nella stringa in cui la sottostringa *sub* è "
"trovata all'interno dell'intervallo ``s[start:end]``. Gli argomenti "
"opzionali *start* e *end* sono interpretati come nella notazione delle "
"slice. Restituisce ``-1`` se *sub* non viene trovata."

#: library/stdtypes.rst:1732
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Il metodo :meth:`~str.find` dovrebbe essere utilizzato solo se si ha bisogno "
"di conoscere la posizione di *sub*. Per verificare se *sub* è una "
"sottostringa o meno, usa l'operatore :keyword:`in`::"

#: library/stdtypes.rst:1742
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Esegui un'operazione di formattazione della stringa. La stringa su cui viene "
"chiamato questo metodo può contenere testo letterale o campi di sostituzione "
"delimitati da parentesi graffe ``{}``. Ogni campo di sostituzione contiene "
"l'indice numerico di un argomento posizionale o il nome di un argomento "
"keyword. Restituisce una copia della stringa dove ogni campo di sostituzione "
"è sostituito con il valore della stringa dell'argomento corrispondente."

#: library/stdtypes.rst:1752
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Vedi :ref:`formatstrings` per una descrizione delle varie opzioni di "
"formattazione che possono essere specificate nelle stringhe di formattazione."

#: library/stdtypes.rst:1756
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Quando si formatta un numero (:class:`int`, :class:`float`, :class:"
"`complex`, :class:`decimal.Decimal` e sottoclassi) con il tipo ``n`` (es: "
"``'{:n}'.format(1234)``), la funzione imposta temporaneamente il locale "
"``LC_CTYPE`` sul locale ``LC_NUMERIC`` per decodificare i campi "
"``decimal_point`` e ``thousands_sep`` di :c:func:`localeconv` se sono non-"
"ASCII o più lunghi di 1 byte, e il locale ``LC_NUMERIC`` è diverso dal "
"locale ``LC_CTYPE``. Questo cambiamento temporaneo influisce su altri thread."

#: library/stdtypes.rst:1765
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Quando si formatta un numero con il tipo ``n``, la funzione imposta "
"temporaneamente il locale ``LC_CTYPE`` sul locale ``LC_NUMERIC`` in alcuni "
"casi."

#: library/stdtypes.rst:1773
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Simile a ``str.format(**mapping)``, tranne che ``mapping`` viene utilizzato "
"direttamente e non copiato in un :class:`dict`. Questo è utile se, per "
"esempio, ``mapping`` è una sottoclasse di dict:"

#: library/stdtypes.rst:1789
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Come :meth:`~str.find`, ma solleva :exc:`ValueError` quando la sottostringa "
"non viene trovata."

#: library/stdtypes.rst:1795
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Restituisce ``True`` se tutti i caratteri della stringa sono alfanumerici e "
"c'è almeno un carattere, ``False`` altrimenti. Un carattere ``c`` è "
"alfanumerico se uno dei seguenti restituisce ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, o ``c.isnumeric()``."

#: library/stdtypes.rst:1803
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the `Alphabetic "
"property defined in the section 4.10 'Letters, Alphabetic, and Ideographic' "
"of the Unicode Standard <https://www.unicode.org/versions/Unicode15.0.0/ch04."
"pdf>`_."
msgstr ""
"Restituisce ``True`` se tutti i caratteri della stringa sono alfabetici e "
"c'è almeno un carattere, ``False`` altrimenti. I caratteri alfabetici sono "
"quei caratteri definiti nel database dei caratteri Unicode come \"Letter\", "
"cioè quelli con la proprietà della categoria generale essere uno tra \"Lm\", "
"\"Lt\", \"Lu\", \"Ll\", o \"Lo\". Si noti che questo è diverso dalla "
"`proprietà alfabetica definita nella sezione 4.10 'Lettere, Alfabetico, e "
"Ideografico' dello Standard Unicode <https://www.unicode.org/versions/"
"Unicode15.1.0/ch04.pdf>`_."

#: library/stdtypes.rst:1814
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Restituisce ``True`` se la stringa è vuota o tutti i caratteri della stringa "
"sono ASCII, ``False`` altrimenti. I caratteri ASCII hanno punti di codice "
"nell'intervallo U+0000-U+007F."

#: library/stdtypes.rst:1823
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Restituisce ``True`` se tutti i caratteri della stringa sono caratteri "
"decimali e c'è almeno un carattere, ``False`` altrimenti. I caratteri "
"decimali sono quelli che possono essere usati per formare numeri in base 10, "
"ad es. U+0660, NUMERO ZERO ARABICO-INDICO. Formalmente, un carattere "
"decimale è un carattere nella categoria generale Unicode \"Nd\"."

#: library/stdtypes.rst:1833
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Restituisce ``True`` se tutti i caratteri della stringa sono cifre e c'è "
"almeno un carattere, ``False`` altrimenti. Le cifre includono i caratteri "
"decimali e le cifre che necessitano di una gestione speciale, come le cifre "
"in apice di compatibilità. Questo copre le cifre che non possono essere "
"usate per formare numeri in base 10, come i numeri Kharosthi. Formalmente, "
"una cifra è un carattere che ha la proprietà Numeric_Type=Digit o "
"Numeric_Type=Decimal."

#: library/stdtypes.rst:1843
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Restituisce ``True`` se la stringa è un identificatore valido secondo la "
"definizione del linguaggio, sezione :ref:`identifiers`."

#: library/stdtypes.rst:1846
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a "
"reserved identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
":func:`keyword.iskeyword` può essere utilizzata per testare se la stringa "
"``s`` è un identificatore riservato, come :keyword:`def` e :keyword:`class`."

#: library/stdtypes.rst:1849
msgid "Example: ::"
msgstr "Esempio: ::"

#: library/stdtypes.rst:1862
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Restituisce ``True`` se tutti i caratteri con distinzione di maiuscole e "
"minuscole [4]_ della stringa sono minuscoli e c'è almeno un carattere con "
"distinzione di maiuscole e minuscole, ``False`` altrimenti."

#: library/stdtypes.rst:1868
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Restituisce ``True`` se tutti i caratteri della stringa sono caratteri "
"numerici, e c'è almeno un carattere, ``False`` altrimenti. I caratteri "
"numerici includono i caratteri delle cifre, e tutti i caratteri che hanno la "
"proprietà valore numerico Unicode, ad es. U+2155, FRAZIONE VOLGARE UN "
"QUINTO. Formalmente, i caratteri numerici sono quelli con la proprietà "
"valore Numeric_Type=Digit, Numeric_Type=Decimal o Numeric_Type=Numeric."

#: library/stdtypes.rst:1878
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Restituisce ``True`` se tutti i caratteri nella stringa sono stampabili o se "
"la stringa è vuota, altrimenti ``False``. I caratteri non stampabili sono "
"quelli definiti nel database dei caratteri Unicode come \"Other\" o "
"\"Separator\", eccetto lo spazio ASCII (0x20) che è considerato stampabile. "
"(Si noti che i caratteri stampabili in questo contesto sono quelli che non "
"devono essere escape quando la funzione :func:`repr` viene invocata su una "
"stringa. Non influisce sulla gestione delle stringhe scritte su :data:`sys."
"stdout` o :data:`sys.stderr`)."

#: library/stdtypes.rst:1889
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Restituisce ``True`` se ci sono solo caratteri di spazio nella stringa e c'è "
"almeno un carattere, altrimenti ``False``."

#: library/stdtypes.rst:1892
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Un carattere è *spazio* se nel database dei caratteri Unicode (vedi :mod:"
"`unicodedata`) la sua categoria generale è ``Zs`` (\"Separator, space\"), o "
"se la sua classe bidirezionale è una delle seguenti ``WS``, ``B``, o ``S``."

#: library/stdtypes.rst:1900
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Restituisce ``True`` se la stringa è una stringa con iniziale maiuscola e "
"c'è almeno un carattere; ad esempio, i caratteri maiuscoli possono seguire "
"solo caratteri senza distinzione maiuscola o minuscola e i caratteri "
"minuscoli solo quelli con distinzione. Restituisce ``False`` altrimenti."

#: library/stdtypes.rst:1907
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Restituisce ``True`` se tutti i caratteri con distinzione [4]_ nella stringa "
"sono maiuscoli e c'è almeno un carattere con distinzione, altrimenti "
"``False``."

#: library/stdtypes.rst:1925
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Restituisce una stringa che è la concatenazione delle stringhe in "
"*iterable*. Verrà sollevato un :exc:`TypeError` se ci sono valori non "
"stringa in *iterable*, inclusi gli oggetti di tipo :class:`bytes`. Il "
"separatore tra gli elementi è la stringa che fornisce questo metodo."

#: library/stdtypes.rst:1933
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Restituisce la stringa allineata a sinistra in una stringa di lunghezza "
"*width*. La spaziatura viene eseguita utilizzando il *fillchar* specificato "
"(il valore predefinito è uno spazio ASCII). La stringa originale viene "
"restituita se *width* è minore o uguale alla lunghezza di ``len(s)``."

#: library/stdtypes.rst:1940
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Restituisce una copia della stringa con tutti i caratteri con distinzione "
"[4]_ convertiti in minuscolo."

#: library/stdtypes.rst:1943
#, fuzzy
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""
"L'algoritmo di conversione in minuscolo utilizzato è `descritto nella "
"sezione 3.13 'Default Case Folding' dello Standard Unicode <https://www."
"unicode.org/versions/Unicode15.1.0/ch03.pdf>`__."

#: library/stdtypes.rst:1950
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Restituisce una copia della stringa con i caratteri iniziali rimossi. "
"L'argomento *chars* è una stringa che specifica l'insieme di caratteri da "
"rimuovere. Se omesso o ``None``, l'argomento *chars* predefinito rimuove gli "
"spazi bianchi. L'argomento *chars* non è un prefisso; piuttosto, tutte le "
"combinazioni dei suoi valori vengono rimosse::"

#: library/stdtypes.rst:1960
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Vedi :meth:`str.removeprefix` per un metodo che rimuova un singolo prefisso "
"stringa piuttosto che tutti i caratteri di un insieme. Ad esempio::"

#: library/stdtypes.rst:1971
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Questo metodo statico restituisce una tabella di traduzione utilizzabile "
"per :meth:`str.translate`."

#: library/stdtypes.rst:1973
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Se c'è solo un argomento, deve essere un dizionario che mappa gli ordinali "
"Unicode (interi) o caratteri (stringhe di lunghezza 1) a ordinali Unicode, "
"stringhe (di lunghezza arbitraria) o ``None``. Le chiavi dei caratteri "
"verranno quindi convertite in ordinali."

#: library/stdtypes.rst:1978
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Se ci sono due argomenti, devono essere stringhe della stessa lunghezza, e "
"nel dizionario risultante, ciascun carattere in x sarà mappato al carattere "
"nella stessa posizione in y. Se c'è un terzo argomento, deve essere una "
"stringa, i cui caratteri verranno mappati a ``None`` nel risultato."

#: library/stdtypes.rst:1986
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Divide la stringa alla prima occorrenza di *sep*, e restituisce una tuple a "
"3 elementi contenente la parte prima del separatore, il separatore stesso, e "
"la parte dopo il separatore. Se il separatore non viene trovato, restituisce "
"una tuple a 3 elementi contenente la stringa stessa, seguita da due stringhe "
"vuote."

#: library/stdtypes.rst:1994
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Se la stringa inizia con la stringa *prefix*, restituisce "
"``string[len(prefix):]``. Altrimenti, restituisce una copia della stringa "
"originale::"

#: library/stdtypes.rst:2008
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Se la stringa termina con la stringa *suffix* e tale *suffix* non è vuota, "
"restituisce ``string[:-len(suffix)]``. Altrimenti, restituisce una copia "
"della stringa originale::"

#: library/stdtypes.rst:2022
#, fuzzy
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Restituisce una copia della sequenza con tutte le occorrenze della "
"sottosequenza *old* sostituite da *new*. Se viene specificato l'argomento "
"opzionale *count*, vengono sostituite solo le prime *count* occorrenze."

#: library/stdtypes.rst:2029
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Restituisce l'indice più alto nella stringa dove la sottostringa *sub* viene "
"trovata, in modo tale che *sub* sia contenuta in ``s[start:end]``. Gli "
"argomenti opzionali *start* e *end* sono interpretati come nella notazione "
"delle sezioni. Restituisce ``-1`` in caso di fallimento."

#: library/stdtypes.rst:2036
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Come :meth:`rfind` ma solleva :exc:`ValueError` quando la sottostringa *sub* "
"non viene trovata."

#: library/stdtypes.rst:2042
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Restituisce la stringa allineata a destra in una stringa di lunghezza "
"*width*. La spaziatura viene eseguita utilizzando il *fillchar* specificato "
"(il valore predefinito è uno spazio ASCII). La stringa originale viene "
"restituita se *width* è minore o uguale alla lunghezza di ``len(s)``."

#: library/stdtypes.rst:2049
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Divide la stringa all'ultima occorrenza di *sep*, e restituisce una tuple a "
"3 elementi contenente la parte prima del separatore, il separatore stesso, e "
"la parte dopo il separatore. Se il separatore non viene trovato, restituisce "
"una tuple a 3 elementi contenente due stringhe vuote, seguite dalla stringa "
"stessa."

#: library/stdtypes.rst:2057
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Restituisce un elenco delle parole nella stringa, utilizzando *sep* come "
"stringa delimitante. Se è dato *maxsplit*, sono eseguite al massimo "
"*maxsplit* divisioni, quelle più a destra. Se *sep* non è specificato o è "
"``None``, qualsiasi stringa di spazi bianchi è un separatore. A eccezione "
"della divisione da destra, :meth:`rsplit` si comporta come :meth:`split` che "
"viene descritto in dettaglio sotto."

#: library/stdtypes.rst:2066
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Restituisce una copia della stringa con i caratteri finali rimossi. "
"L'argomento *chars* è una stringa che specifica l'insieme di caratteri da "
"rimuovere. Se omesso o ``None``, l'argomento *chars* predefinito rimuove gli "
"spazi bianchi. L'argomento *chars* non è un suffisso; piuttosto, tutte le "
"combinazioni dei suoi valori vengono rimosse::"

#: library/stdtypes.rst:2076
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Vedi :meth:`str.removesuffix` per un metodo che rimuova un singolo suffisso "
"stringa piuttosto che tutti i caratteri di un insieme. Ad esempio::"

#: library/stdtypes.rst:2086
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Restituisce un elenco delle parole nella stringa, utilizzando *sep* come "
"stringa delimitante. Se è dato *maxsplit*, sono eseguite al massimo "
"*maxsplit* divisioni (quindi, l'elenco avrà al massimo ``maxsplit+1`` "
"elementi). Se *maxsplit* non è specificato o è ``-1``, allora non c'è limite "
"al numero di divisioni (vengono eseguite tutte le divisioni possibili)."

#: library/stdtypes.rst:2092
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Se è fornito *sep*, i delimitatori consecutivi non sono raggruppati insieme "
"e si ritiene delimitino stringhe vuote (ad esempio, ``'1,,2'.split(',')`` "
"restituisce ``['1', '', '2']``). L'argomento *sep* può consistere di più "
"caratteri (ad esempio, ``'1<>2<>3'.split('<>')`` restituisce ``['1', '2', "
"'3']``). Dividendo una stringa vuota con un separatore specificato si "
"ottiene ``['']``."

#: library/stdtypes.rst:2114 library/stdtypes.rst:2234
#: library/stdtypes.rst:3149 library/stdtypes.rst:3256
#: library/stdtypes.rst:3297 library/stdtypes.rst:3339
#: library/stdtypes.rst:3371 library/stdtypes.rst:3421
#: library/stdtypes.rst:3490 library/stdtypes.rst:3514
msgid "For example::"
msgstr "Ad esempio::"

#: library/stdtypes.rst:2107
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Se *sep* non è specificato o è ``None``, viene applicato un algoritmo di "
"divisione diverso: sequenze di spazi bianchi consecutivi sono considerate "
"come un unico separatore, e il risultato non conterrà stringhe vuote "
"all'inizio o alla fine se la stringa ha spazi bianchi iniziali o finali. Di "
"conseguenza, dividendo una stringa vuota o una stringa composta solo di "
"spazi bianchi con un separatore ``None`` si ottiene ``[]``."

#: library/stdtypes.rst:2129
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Restituisce un elenco delle righe nella stringa, suddividendo alle linee di "
"demarcazione. Le interruzioni di linea non sono incluse nell'elenco "
"risultante a meno che *keepends* non sia dato e vero."

#: library/stdtypes.rst:2133
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Questo metodo divide sulle seguenti linee di demarcazione. In particolare, i "
"confini sono un sovrainsieme delle :term:`universal newlines`."

#: library/stdtypes.rst:2137
msgid "Representation"
msgstr "Rappresentazione"

#: library/stdtypes.rst:2137
msgid "Description"
msgstr "Descrizione"

#: library/stdtypes.rst:2139
msgid "``\\n``"
msgstr "``\\n``"

#: library/stdtypes.rst:2139
msgid "Line Feed"
msgstr "Line Feed"

#: library/stdtypes.rst:2141
msgid "``\\r``"
msgstr "``\\r``"

#: library/stdtypes.rst:2141
msgid "Carriage Return"
msgstr "Carriage Return"

#: library/stdtypes.rst:2143
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: library/stdtypes.rst:2143
msgid "Carriage Return + Line Feed"
msgstr "Carriage Return + Line Feed"

#: library/stdtypes.rst:2145
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` o ``\\x0b``"

#: library/stdtypes.rst:2145
msgid "Line Tabulation"
msgstr "Line Tabulation"

#: library/stdtypes.rst:2147
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` o ``\\x0c``"

#: library/stdtypes.rst:2147
msgid "Form Feed"
msgstr "Form Feed"

#: library/stdtypes.rst:2149
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: library/stdtypes.rst:2149
msgid "File Separator"
msgstr "File Separator"

#: library/stdtypes.rst:2151
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: library/stdtypes.rst:2151
msgid "Group Separator"
msgstr "Group Separator"

#: library/stdtypes.rst:2153
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: library/stdtypes.rst:2153
msgid "Record Separator"
msgstr "Record Separator"

#: library/stdtypes.rst:2155
msgid "``\\x85``"
msgstr "``\\x85``"

#: library/stdtypes.rst:2155
msgid "Next Line (C1 Control Code)"
msgstr "Codice di controllo C1 \"Next Line\""

#: library/stdtypes.rst:2157
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: library/stdtypes.rst:2157
msgid "Line Separator"
msgstr "Separatore di riga"

#: library/stdtypes.rst:2159
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: library/stdtypes.rst:2159
msgid "Paragraph Separator"
msgstr "Separatore di paragrafo"

#: library/stdtypes.rst:2164
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` e ``\\f`` aggiunti all'elenco dei limiti di riga."

#: library/stdtypes.rst:2173
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"A differenza del metodo :meth:`~str.split` quando viene fornita una stringa "
"delimitatore *sep*, questo metodo restituisce una lista vuota per la stringa "
"vuota e un'interruzione di riga terminale non comporta una linea aggiuntiva::"

#: library/stdtypes.rst:2182
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Per confronto, ``split('\\n')`` restituisce::"

#: library/stdtypes.rst:2192
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Restituisce ``True`` se la stringa inizia con il *prefisso*, altrimenti "
"restituisce ``False``. *prefix* può essere anche una tupla di prefissi da "
"cercare. Con *start* opzionale, testa la stringa iniziando da quella "
"posizione. Con *end* opzionale, smette di confrontare la stringa in quella "
"posizione."

#: library/stdtypes.rst:2200
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Restituisce una copia della stringa con i caratteri iniziali e finali "
"rimossi. L'argomento *chars* è una stringa che specifica l'insieme dei "
"caratteri da rimuovere. Se omesso o ``None``, l'argomento *chars* "
"predefinisce la rimozione degli spazi bianchi. L'argomento *chars* non è un "
"prefisso o un suffisso; piuttosto, tutte le combinazioni dei suoi valori "
"vengono eliminate::"

#: library/stdtypes.rst:2211
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"I valori esterni iniziali e finali dell'argomento *chars* vengono rimossi "
"dalla stringa. I caratteri vengono rimossi dall'inizio fino a raggiungere un "
"carattere della stringa che non è contenuto nel set di caratteri in *chars*. "
"Un'azione simile avviene alla fine. Per esempio::"

#: library/stdtypes.rst:2224
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Restituisce una copia della stringa con i caratteri maiuscoli convertiti in "
"minuscoli e viceversa. Nota che non è necessariamente vero che ``s."
"swapcase().swapcase() == s``."

#: library/stdtypes.rst:2231
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Restituisce una versione della stringa con iniziali maiuscole, dove le "
"parole iniziano con un carattere maiuscolo e i caratteri rimanenti sono "
"minuscoli."

#: library/stdtypes.rst:3458
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"L'algoritmo utilizza una semplice definizione indipendente dalla lingua di "
"una parola come gruppi di lettere consecutive. La definizione funziona in "
"molti contesti, ma ciò significa che gli apostrofi nelle contrazioni e nei "
"possessivi formano confini di parola, il che potrebbe non essere il "
"risultato desiderato::"

#: library/stdtypes.rst:2247
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
"La funzione :func:`string.capwords` non ha questo problema, poiché divide le "
"parole solo sugli spazi."

#: library/stdtypes.rst:2250
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"In alternativa, è possibile costruire una soluzione per gli apostrofi "
"utilizzando le espressioni regolari::"

#: library/stdtypes.rst:2265
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`~object.__getitem__`, typically a :term:`mapping` or :"
"term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Restituisce una copia della stringa in cui ciascun carattere è stato mappato "
"attraverso la tabella di traduzione fornita. La tabella deve essere un "
"oggetto che implementa l'indicizzazione tramite :meth:`~object.__getitem__`, "
"tipicamente un :term:`mapping` o una :term:`sequence`. Quando indicizzato "
"tramite un ordinale Unicode (un intero), l'oggetto tabella può fare una "
"delle seguenti azioni: restituire un ordinale Unicode o una stringa, per "
"mappare il carattere a uno o più altri caratteri; restituire ``None``, per "
"eliminare il carattere dalla stringa di ritorno; o lanciare un'eccezione :"
"exc:`LookupError`, per mappare il carattere a se stesso."

#: library/stdtypes.rst:2274
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Puoi usare :meth:`str.maketrans` per creare una mappa di traduzione da "
"mappature carattere-a-carattere in diversi formati."

#: library/stdtypes.rst:2277
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Vedi anche il modulo :mod:`codecs` per un approccio più flessibile alle "
"mappature personalizzate dei caratteri."

#: library/stdtypes.rst:2283
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Restituisce una copia della stringa con tutti i caratteri [4]_ in maiuscolo "
"convertiti in maiuscolo. Nota che ``s.upper().isupper()`` potrebbe essere "
"``False`` se ``s`` contiene caratteri non maiuscoli o se la categoria "
"Unicode dei caratteri risultanti non è \"Lu\" (Lettera, maiuscolo), ma ad "
"esempio \"Lt\" (Lettera, titolo)."

#: library/stdtypes.rst:2289
#, fuzzy
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""
"L'algoritmo di conversione in maiuscolo usato è `descritto nella sezione "
"3.13 'Default Case Folding' dello Standard Unicode <https://www.unicode.org/"
"versions/Unicode15.1.0/ch03.pdf>`__."

#: library/stdtypes.rst:2296
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Restituisce una copia della stringa riempita a sinistra con cifre ASCII "
"``'0'`` per fare una stringa della lunghezza *width*. Un prefisso di segno "
"principale (``'+'``/``'-'``) viene gestito inserendo il padding *dopo* il "
"carattere del segno piuttosto che prima. La stringa originale viene "
"restituita se *width* è minore o uguale a ``len(s)``."

#: library/stdtypes.rst:2314
msgid "``printf``-style String Formatting"
msgstr "Formattazione delle stringhe in stile ``printf``"

#: library/stdtypes.rst:2327
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Le operazioni di formattazione descritte qui mostrano una varietà di "
"caratteristiche particolari che portano a numerosi errori comuni (come il "
"fallimento nel visualizzare correttamente tuple e dizionari). Utilizzare le "
"più recenti :ref:`stringhe letterali formattate <f-strings>`, l'interfaccia :"
"meth:`str.format`, o :ref:`stringhe template <template-strings>` potrebbe "
"aiutare a evitare questi errori. Ciascuna di queste alternative offre i "
"propri compromessi e vantaggi di semplicità, flessibilità e/o estensibilità."

#: library/stdtypes.rst:2335
#, fuzzy
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Gli oggetti stringa hanno un'operazione integrata unica: l'operatore ``%`` "
"(modulo). Questo è anche noto come operatore di *formattazione* o "
"*interpolazione* della stringa. Data ``format % values`` (dove *format* è "
"una stringa), le specifiche di conversione ``%`` in *format* sono sostituite "
"con uno o più elementi di *values*. L'effetto è simile all'uso della "
"funzione :c:func:`sprintf` nel linguaggio C. Per esempio:"

#: library/stdtypes.rst:2341
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Se *format* richiede un singolo argomento, *values* può essere un singolo "
"oggetto che non è una tupla. [5]_ Altrimenti, *values* deve essere una tupla "
"con esattamente il numero di elementi specificati dalla stringa di "
"formattazione, o un singolo oggetto di mappatura (ad esempio, un dizionario)."

#: library/stdtypes.rst:3569
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Uno specificatore di conversione contiene due o più caratteri e ha i "
"seguenti componenti, che devono apparire in questo ordine:"

#: library/stdtypes.rst:3572
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Il carattere ``'%'``, che segna l'inizio dello specificatore."

#: library/stdtypes.rst:3574
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Chiave di mappatura (opzionale), costituita da una sequenza tra parentesi di "
"caratteri (ad esempio, ``(somename)``)."

#: library/stdtypes.rst:3577
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Flag di conversione (opzionali), che influiscono sul risultato di alcuni "
"tipi di conversione."

#: library/stdtypes.rst:3580
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Larghezza minima del campo (opzionale). Se specificata come ``'*'`` "
"(asterisco), la larghezza effettiva viene letta dal prossimo elemento della "
"tupla in *values*, e l'oggetto da convertire viene dopo la larghezza minima "
"del campo e la precisione opzionale."

#: library/stdtypes.rst:3584
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Precisione (opzionale), data come ``'.'`` (punto) seguita dalla precisione. "
"Se specificata come ``'*'`` (un asterisco), la precisione effettiva viene "
"letta dal prossimo elemento della tupla in *values*, e il valore da "
"convertire viene dopo la precisione."

#: library/stdtypes.rst:3589
msgid "Length modifier (optional)."
msgstr "Modificatore di lunghezza (opzionale)."

#: library/stdtypes.rst:3591
msgid "Conversion type."
msgstr "Tipo di conversione."

#: library/stdtypes.rst:2375
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Quando l'argomento di destra è un dizionario (o un altro tipo di mappatura), "
"i formati nella stringa *devono* includere una chiave di mappatura tra "
"parentesi in quel dizionario inserita immediatamente dopo il carattere "
"``'%'``. La chiave di mappatura seleziona il valore da formattare dalla "
"mappatura. Ad esempio:"

#: library/stdtypes.rst:3602
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"In questo caso non possono comparire specificatori ``*`` in un formato "
"(poiché richiedono un elenco di parametri sequenziale)."

#: library/stdtypes.rst:3605
msgid "The conversion flag characters are:"
msgstr "I caratteri di flag di conversione sono:"

#: library/stdtypes.rst:3614
msgid "Flag"
msgstr "Flag"

#: library/stdtypes.rst:3616
msgid "``'#'``"
msgstr "``'#'``"

#: library/stdtypes.rst:3616
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"La conversione del valore utilizzerà la \"forma alternativa\" (dove definita "
"di seguito)."

#: library/stdtypes.rst:3619
msgid "``'0'``"
msgstr "``'0'``"

#: library/stdtypes.rst:3619
msgid "The conversion will be zero padded for numeric values."
msgstr "La conversione sarà riempita di zeri per i valori numerici."

#: library/stdtypes.rst:3621
msgid "``'-'``"
msgstr "``'-'``"

#: library/stdtypes.rst:3621
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"Il valore convertito è allineato a sinistra (sovrascrive la conversione "
"``'0'`` se entrambi sono forniti)."

#: library/stdtypes.rst:3624
msgid "``' '``"
msgstr "``' '``"

#: library/stdtypes.rst:3624
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(uno spazio) Uno spazio vuoto dovrebbe essere lasciato prima di un numero "
"positivo (o stringa vuota) prodotto da una conversione con segno."

#: library/stdtypes.rst:3627
msgid "``'+'``"
msgstr "``'+'``"

#: library/stdtypes.rst:3627
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Un carattere di segno (``'+'`` o ``'-'``) precederà la conversione "
"(sovrascrive un flag \"spazio\")."

#: library/stdtypes.rst:3631
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Un modificatore di lunghezza (``h``, ``l``, o ``L``) può essere presente, ma "
"viene ignorato poiché non è necessario per Python -- quindi ad esempio "
"``%ld`` è identico a ``%d``."

#: library/stdtypes.rst:3634
msgid "The conversion types are:"
msgstr "I tipi di conversione sono:"

#: library/stdtypes.rst:3637
msgid "Conversion"
msgstr "Conversione"

#: library/stdtypes.rst:3639
msgid "``'d'``"
msgstr "``'d'``"

#: library/stdtypes.rst:2423 library/stdtypes.rst:3641
msgid "Signed integer decimal."
msgstr "Intero con segno decimale."

#: library/stdtypes.rst:3641
msgid "``'i'``"
msgstr "``'i'``"

#: library/stdtypes.rst:3643
msgid "``'o'``"
msgstr "``'o'``"

#: library/stdtypes.rst:3643
msgid "Signed octal value."
msgstr "Valore ottale con segno."

#: library/stdtypes.rst:3645
msgid "``'u'``"
msgstr "``'u'``"

#: library/stdtypes.rst:3645
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Tipo obsoleto -- è identico a ``'d'``."

#: library/stdtypes.rst:3647
msgid "``'x'``"
msgstr "``'x'``"

#: library/stdtypes.rst:3647
msgid "Signed hexadecimal (lowercase)."
msgstr "Esadecimale con segno (minuscolo)."

#: library/stdtypes.rst:3649
msgid "``'X'``"
msgstr "``'X'``"

#: library/stdtypes.rst:3649
msgid "Signed hexadecimal (uppercase)."
msgstr "Esadecimale con segno (maiuscolo)."

#: library/stdtypes.rst:3651
msgid "``'e'``"
msgstr "``'e'``"

#: library/stdtypes.rst:3651
msgid "Floating point exponential format (lowercase)."
msgstr "Formato esponenziale a virgola mobile (minuscolo)."

#: library/stdtypes.rst:3653
msgid "``'E'``"
msgstr "``'E'``"

#: library/stdtypes.rst:3653
msgid "Floating point exponential format (uppercase)."
msgstr "Formato esponenziale a virgola mobile (maiuscolo)."

#: library/stdtypes.rst:3655
msgid "``'f'``"
msgstr "``'f'``"

#: library/stdtypes.rst:2439 library/stdtypes.rst:3657
msgid "Floating point decimal format."
msgstr "Formato decimale a virgola mobile."

#: library/stdtypes.rst:3657
msgid "``'F'``"
msgstr "``'F'``"

#: library/stdtypes.rst:3659
msgid "``'g'``"
msgstr "``'g'``"

#: library/stdtypes.rst:3659
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato a virgola mobile. Usa formato esponenziale minuscolo se l'esponente "
"è inferiore a -4 o non inferiore alla precisione, altrimenti formato "
"decimale."

#: library/stdtypes.rst:3663
msgid "``'G'``"
msgstr "``'G'``"

#: library/stdtypes.rst:3663
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato a virgola mobile. Usa formato esponenziale maiuscolo se l'esponente "
"è inferiore a -4 o non inferiore alla precisione, altrimenti formato "
"decimale."

#: library/stdtypes.rst:3667
msgid "``'c'``"
msgstr "``'c'``"

#: library/stdtypes.rst:2449
msgid "Single character (accepts integer or single character string)."
msgstr ""
"Singolo carattere (accetta un intero o una stringa di un singolo carattere)."

#: library/stdtypes.rst:3680
msgid "``'r'``"
msgstr "``'r'``"

#: library/stdtypes.rst:2452
msgid "String (converts any Python object using :func:`repr`)."
msgstr "Stringa (converte qualsiasi oggetto Python usando :func:`repr`)."

#: library/stdtypes.rst:3674
msgid "``'s'``"
msgstr "``'s'``"

#: library/stdtypes.rst:2455
msgid "String (converts any Python object using :func:`str`)."
msgstr "Stringa (converte qualsiasi oggetto Python usando :func:`str`)."

#: library/stdtypes.rst:3677
msgid "``'a'``"
msgstr "``'a'``"

#: library/stdtypes.rst:2458
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "Stringa (converte qualsiasi oggetto Python usando :func:`ascii`)."

#: library/stdtypes.rst:3683
msgid "``'%'``"
msgstr "``'%'``"

#: library/stdtypes.rst:3683
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Nessun argomento viene convertito, il risultato è un carattere ``'%'`` nel "
"risultato."

#: library/stdtypes.rst:3690
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"La forma alternativa fa sì che venga inserito un prefisso ottale (``'0o'``) "
"prima della prima cifra."

#: library/stdtypes.rst:3694
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"La forma alternativa fa sì che venga inserito un prefisso ``'0x'`` o "
"``'0X'`` (a seconda che sia stato usato il formato ``'x'`` o ``'X'``) prima "
"della prima cifra."

#: library/stdtypes.rst:3698
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"La forma alternativa fa sì che il risultato contenga sempre un punto "
"decimale, anche se non ci sono cifre che seguono."

#: library/stdtypes.rst:3701
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"La precisione determina il numero di cifre dopo il punto decimale e il "
"valore predefinito è 6."

#: library/stdtypes.rst:3705
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"La forma alternativa fa sì che il risultato contenga sempre un punto "
"decimale e gli zeri finali non vengono rimossi come avverrebbe altrimenti."

#: library/stdtypes.rst:3708
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"La precisione determina il numero di cifre significative prima e dopo il "
"punto decimale e il valore predefinito è 6."

#: library/stdtypes.rst:3712
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Se la precisione è ``N``, l'output è troncato a ``N`` caratteri."

#: library/stdtypes.rst:3721
msgid "See :pep:`237`."
msgstr "Vedi :pep:`237`."

#: library/stdtypes.rst:2495
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Poiché le stringhe Python hanno una lunghezza esplicita, le conversioni "
"``%s`` non assumono che ``'\\0'`` sia la fine della stringa."

#: library/stdtypes.rst:2500
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Le conversioni ``%f`` per i numeri il cui valore assoluto è superiore a 1e50 "
"non vengono più sostituite dalle conversioni ``%g``."

#: library/stdtypes.rst:2511
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Tipi di sequenze binarie --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: library/stdtypes.rst:2519
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"I tipi incorporati principali per manipolare i dati binari sono :class:"
"`bytes` e :class:`bytearray`. Sono supportati da :class:`memoryview` che "
"utilizza il :ref:`protocollo buffer <bufferobjects>` per accedere alla "
"memoria di altri oggetti binari senza necessità di fare una copia."

#: library/stdtypes.rst:2524
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Il modulo :mod:`array` supporta l'archiviazione efficiente di tipi di dati "
"di base come interi a 32 bit e valori a virgola mobile a doppia precisione "
"IEEE754."

#: library/stdtypes.rst:2530
msgid "Bytes Objects"
msgstr "Oggetti bytes"

#: library/stdtypes.rst:2534
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Gli oggetti bytes sono sequenze immutabili di singoli byte. Poiché molti "
"protocolli binari principali sono basati sulla codifica del testo ASCII, gli "
"oggetti bytes offrono diversi metodi validi solo quando si lavora con dati "
"compatibili con ASCII e sono strettamente correlati agli oggetti stringa in "
"vari altri modi."

#: library/stdtypes.rst:2541
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"In primo luogo, la sintassi per i letterali bytes è sostanzialmente la "
"stessa di quella per i letterali stringa, tranne per il fatto che viene "
"aggiunto un prefisso ``b``:"

#: library/stdtypes.rst:2544
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "Virgolette singole: ``b'still allows embedded \"double\" quotes'``"

#: library/stdtypes.rst:2545
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "Virgolette doppie: ``b\"still allows embedded 'single' quotes\"``"

#: library/stdtypes.rst:2546
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Virgolette triple: ``b'''3 single quotes'''``, ``b\"\"\"3 double "
"quotes\"\"\"``"

#: library/stdtypes.rst:2548
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Sono permessi solo caratteri ASCII nei letterali bytes (indipendentemente "
"dalla codifica dichiarata del codice sorgente). Qualsiasi valore binario "
"superiore a 127 deve essere inserito nei letterali bytes usando la sequenza "
"di escape appropriata."

#: library/stdtypes.rst:2552
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Come per i letterali stringa, i letterali bytes possono anche usare il "
"prefisso ``r`` per disabilitare l'elaborazione delle sequenze di escape. "
"Vedi :ref:`strings` per maggiori informazioni sulle varie forme di letterali "
"bytes, comprese le sequenze di escape supportate."

#: library/stdtypes.rst:2556
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Sebbene i letterali bytes e le loro rappresentazioni si basino sul testo "
"ASCII, gli oggetti bytes si comportano effettivamente come sequenze "
"immutabili di interi, con ciascun valore nella sequenza limitato in modo "
"tale che ``0 <= x < 256`` (i tentativi di violare questa restrizione "
"attiveranno :exc:`ValueError`). Questo viene fatto deliberatamente per "
"enfatizzare che, sebbene molti formati binari includano elementi basati su "
"ASCII e possano essere utilmente manipolati con alcuni algoritmi orientati "
"al testo, questo non è generalmente il caso per dati binari arbitrari "
"(applicare ciecamente algoritmi di elaborazione del testo a formati di dati "
"binari non compatibili con ASCII di solito porta a corruzione dei dati)."

#: library/stdtypes.rst:2566
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Oltre alle forme letterali, gli oggetti bytes possono essere creati in "
"diversi altri modi:"

#: library/stdtypes.rst:2569
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""
"Un oggetto bytes riempito di zeri di una lunghezza specificata: ``bytes(10)``"

#: library/stdtypes.rst:2570
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "Da un iterable di interi: ``bytes(range(20))``"

#: library/stdtypes.rst:2571
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Copiando dati binari esistenti tramite il protocollo buffer: ``bytes(obj)``"

#: library/stdtypes.rst:2573
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Vedi anche il built-in :ref:`bytes <func-bytes>`."

#: library/stdtypes.rst:2575
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Poiché 2 cifre esadecimali corrispondono esattamente a un singolo byte, i "
"numeri esadecimali sono un formato comunemente usato per descrivere i dati "
"binari. Di conseguenza, il tipo bytes ha un metodo di classe aggiuntivo per "
"leggere i dati in tale formato:"

#: library/stdtypes.rst:2581
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Questo metodo di classe :class:`bytes` restituisce un oggetto bytes, "
"decodificando il dato oggetto stringa. La stringa deve contenere due cifre "
"esadecimali per byte, e gli spazi bianchi ASCII vengono ignorati."

#: library/stdtypes.rst:2588
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` ora salta tutti gli spazi bianchi ASCII nella stringa, "
"non solo gli spazi."

#: library/stdtypes.rst:2592
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Esiste una funzione di conversione inversa per trasformare un oggetto bytes "
"nella sua rappresentazione esadecimale."

#: library/stdtypes.rst:2682
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Restituisce un oggetto stringa contenente due cifre esadecimali per ogni "
"byte nell'istanza."

#: library/stdtypes.rst:2603
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"Se vuoi rendere la stringa esadecimale più leggibile, puoi specificare un "
"parametro separatore *sep* per includere un singolo carattere nell'output. "
"Per impostazione predefinita, questo separatore verrà incluso tra ogni byte. "
"Un secondo parametro opzionale *bytes_per_sep* controlla la spaziatura. I "
"valori positivi calcolano la posizione del separatore da destra, i valori "
"negativi da sinistra."

#: library/stdtypes.rst:2620
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` ora supporta i parametri opzionali *sep* e *bytes_per_sep* "
"per inserire separatori tra i byte nell'output esadecimale."

#: library/stdtypes.rst:2624
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Poiché gli oggetti bytes sono sequenze di interi (simili a una tupla), per "
"un oggetto bytes *b*, ``b[0]`` sarà un intero, mentre ``b[0:1]`` sarà un "
"oggetto bytes di lunghezza 1. (Questo contrasta con le stringhe di testo, "
"dove sia l'indicizzazione che il slicing produrranno una stringa di "
"lunghezza 1)"

#: library/stdtypes.rst:2629
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"La rappresentazione degli oggetti bytes usa il formato letterale "
"(``b'...'``) poiché è spesso più utile di, ad esempio, ``bytes([46, 46, "
"46])``. Puoi sempre convertire un oggetto bytes in una lista di interi "
"usando ``list(b)``."

#: library/stdtypes.rst:2637
msgid "Bytearray Objects"
msgstr "Oggetti Bytearray"

#: library/stdtypes.rst:2641
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Gli oggetti :class:`bytearray` sono una controparte mutabile degli oggetti :"
"class:`bytes`."

#: library/stdtypes.rst:2646
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Non esiste una sintassi letterale dedicata per gli oggetti bytearray, essi "
"vengono sempre creati chiamando il costruttore:"

#: library/stdtypes.rst:2649
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Creazione di un'istanza vuota: ``bytearray()``"

#: library/stdtypes.rst:2650
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Creazione di un'istanza riempita di zeri con una lunghezza data: "
"``bytearray(10)``"

#: library/stdtypes.rst:2651
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "Da un iterable di interi: ``bytearray(range(20))``"

#: library/stdtypes.rst:2652
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Copiando dati binari esistenti tramite il protocollo buffer: "
"``bytearray(b'Hi!')``"

#: library/stdtypes.rst:2654
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Poiché gli oggetti bytearray sono mutabili, supportano le operazioni di "
"sequenza :ref:`mutable <typesseq-mutable>` oltre alle comuni operazioni "
"bytes e bytearray descritte in :ref:`bytes-methods`."

#: library/stdtypes.rst:2658
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Vedi anche il built-in :ref:`bytearray <func-bytearray>`."

#: library/stdtypes.rst:2660
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Poiché 2 cifre esadecimali corrispondono esattamente a un singolo byte, i "
"numeri esadecimali sono un formato comunemente usato per descrivere i dati "
"binari. Di conseguenza, il tipo bytearray ha un metodo di classe aggiuntivo "
"per leggere i dati in tale formato:"

#: library/stdtypes.rst:2666
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Questo metodo di classe :class:`bytearray` restituisce un oggetto bytearray, "
"decodificando il dato oggetto stringa. La stringa deve contenere due cifre "
"esadecimali per byte, e gli spazi bianchi ASCII vengono ignorati."

#: library/stdtypes.rst:2673
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` ora salta tutti gli spazi bianchi ASCII nella "
"stringa, non solo gli spazi."

#: library/stdtypes.rst:2677
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Esiste una funzione di conversione inversa per trasformare un oggetto "
"bytearray nella sua rappresentazione esadecimale."

#: library/stdtypes.rst:2690
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Simile a :meth:`bytes.hex`, :meth:`bytearray.hex` ora supporta i parametri "
"opzionali *sep* e *bytes_per_sep* per inserire separatori tra i byte "
"nell'output esadecimale."

#: library/stdtypes.rst:2695
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Poiché gli oggetti bytearray sono sequenze di interi (simili a una lista), "
"per un oggetto bytearray *b*, ``b[0]`` sarà un intero, mentre ``b[0:1]`` "
"sarà un oggetto bytearray di lunghezza 1. (Questo contrasta con le stringhe "
"di testo, dove sia l'indicizzazione che il slicing produrranno una stringa "
"di lunghezza 1)"

#: library/stdtypes.rst:2700
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"La rappresentazione degli oggetti bytearray usa il formato letterale bytes "
"(``bytearray(b'...')``) poiché è spesso più utile di, ad esempio, "
"``bytearray([46, 46, 46])``. Puoi sempre convertire un oggetto bytearray in "
"una lista di interi usando ``list(b)``."

#: library/stdtypes.rst:2709
msgid "Bytes and Bytearray Operations"
msgstr "Operazioni su Bytes e Bytearray"

#: library/stdtypes.rst:2714
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Sia gli oggetti bytes che bytearray supportano le operazioni di sequenza :"
"ref:`common <typesseq-common>`. Essi interoperano non solo con operandi "
"dello stesso tipo, ma con qualsiasi :term:`bytes-like object`. Grazie a "
"questa flessibilità, possono essere liberamente mescolati nelle operazioni "
"senza causare errori. Tuttavia, il tipo restituito del risultato può "
"dipendere dall'ordine degli operandi."

#: library/stdtypes.rst:2722
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"I metodi sugli oggetti bytes e bytearray non accettano stringhe come "
"argomenti, così come i metodi sulle stringhe non accettano bytes come "
"argomenti. Ad esempio, devi scrivere::"

#: library/stdtypes.rst:2729
msgid "and::"
msgstr "e::"

#: library/stdtypes.rst:2734
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Alcune operazioni su bytes e bytearray presumono l'uso di formati binari "
"compatibili con ASCII e, pertanto, dovrebbero essere evitate quando si "
"lavora con dati binari arbitrari. Queste restrizioni sono trattate di "
"seguito."

#: library/stdtypes.rst:2739
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Utilizzare queste operazioni basate su ASCII per manipolare dati binari che "
"non sono memorizzati in un formato basato su ASCII può portare a corruzione "
"dei dati."

#: library/stdtypes.rst:2742
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"I seguenti metodi sugli oggetti bytes e bytearray possono essere utilizzati "
"con dati binari arbitrari."

#: library/stdtypes.rst:2748
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Restituisce il numero di occorrenze non sovrapposte della sottosequenza "
"*sub* nell'intervallo [*start*, *end*]. Gli argomenti opzionali *start* e "
"*end* sono interpretati come nella notazione di slice."

#: library/stdtypes.rst:2857 library/stdtypes.rst:2945
#: library/stdtypes.rst:2958
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"La sottosequenza da cercare può essere qualsiasi :term:`bytes-like object` o "
"un intero nell'intervallo da 0 a 255."

#: library/stdtypes.rst:2755
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""
"Se *sub* è vuoto, restituisce il numero di slice vuoti tra i caratteri che è "
"la lunghezza dell'oggetto bytes più uno."

#: library/stdtypes.rst:2869 library/stdtypes.rst:2948
#: library/stdtypes.rst:2961
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "Accetta anche un intero nell'intervallo da 0 a 255 come sottosequenza."

#: library/stdtypes.rst:2765
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"Se i dati binari iniziano con la stringa *prefix*, restituisce "
"``bytes[len(prefix):]``. Altrimenti, restituisce una copia dei dati binari "
"originali::"

#: library/stdtypes.rst:2774
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "Il *prefix* può essere qualsiasi :term:`bytes-like object`."

#: library/stdtypes.rst:2800 library/stdtypes.rst:3026
#: library/stdtypes.rst:3071 library/stdtypes.rst:3127
#: library/stdtypes.rst:3215 library/stdtypes.rst:3382
#: library/stdtypes.rst:3480 library/stdtypes.rst:3523
#: library/stdtypes.rst:3725
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"La versione di questo metodo per bytearray non opera *in place* - produce "
"sempre un nuovo oggetto, anche se non sono state apportate modifiche."

#: library/stdtypes.rst:2787
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"Se i dati binari terminano con la stringa *suffix* e questo *suffix* non è "
"vuoto, ritorna ``bytes[:-len(suffix)]``. Altrimenti, ritorna una copia dei "
"dati binari originali::"

#: library/stdtypes.rst:2796
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr ""
"Il *suffix* può essere qualsiasi :term:`oggetto simile a bytes <bytes-like "
"object>`."

#: library/stdtypes.rst:2809
msgid "Return the bytes decoded to a :class:`str`."
msgstr "Restituisce i bytes decodificati in una :class:`str`."

#: library/stdtypes.rst:2814
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* controlla come vengono gestiti gli errori di decodifica. Se "
"``'strict'`` (il valore predefinito), viene sollevata un'eccezione :exc:"
"`UnicodeError`. Altri valori possibili sono ``'ignore'``, ``'replace'``, e "
"qualsiasi altro nome registrato tramite :func:`codecs.register_error`. Vedi :"
"ref:`error-handlers` per i dettagli."

#: library/stdtypes.rst:2820
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"Per ragioni di prestazioni, il valore di *errors* non viene verificato per "
"validità a meno che non si verifichi effettivamente un errore di decodifica, "
"sia abilitato :ref:`devmode` o venga utilizzata una :ref:`build di debug "
"<debug-build>`."

#: library/stdtypes.rst:2826
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""
"Passare l'argomento *encoding* a :class:`str` permette di decodificare "
"qualsiasi :term:`oggetto simile a bytes <bytes-like object>` direttamente, "
"senza dover creare un oggetto temporaneo :class:`!bytes` o :class:`!"
"bytearray`."

#: library/stdtypes.rst:2841
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Restituisce ``True`` se i dati binari terminano con il *suffix* specificato, "
"altrimenti restituisce ``False``. *suffix* può essere anche una tupla di "
"suffissi da cercare. Con *start* opzionale, il test inizia a quella "
"posizione. Con *end* opzionale, smette di confrontare a quella posizione."

#: library/stdtypes.rst:2846
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Il/i suffisso/i da cercare possono essere qualsiasi :term:`oggetto simile a "
"bytes <bytes-like object>`."

#: library/stdtypes.rst:2852
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Restituisce l'indice più basso nei dati dove si trova la sottosequenza "
"*sub*, tale che *sub* sia contenuto nella slice ``s[start:end]``. Gli "
"argomenti opzionali *start* e *end* sono interpretati come nella notazione "
"delle slice. Restituisce ``-1`` se *sub* non viene trovato."

#: library/stdtypes.rst:2862
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Il metodo :meth:`~bytes.find` dovrebbe essere utilizzato solo se hai bisogno "
"di conoscere la posizione di *sub*. Per verificare se *sub* è una "
"sottostringa o no, usa l'operatore :keyword:`in`::"

#: library/stdtypes.rst:2876
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Come :meth:`~bytes.find`, ma solleva :exc:`ValueError` quando la "
"sottosequenza non viene trovata."

#: library/stdtypes.rst:2889
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Restituisce un oggetto bytes o bytearray che è la concatenazione delle "
"sequenze di dati binari in *iterable*. Verrà sollevata una :exc:`TypeError` "
"se ci sono valori in *iterable* che non sono :term:`oggetti simili a bytes "
"<bytes-like object>`, inclusi gli oggetti :class:`str`. Il separatore tra "
"gli elementi è il contenuto dell'oggetto bytes o bytearray che fornisce "
"questo metodo."

#: library/stdtypes.rst:2900
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Questo metodo statico restituisce una tabella di traduzione utilizzabile "
"per :meth:`bytes.translate` che mapperà ciascun carattere in *from* nel "
"carattere nella stessa posizione in *to*; *from* e *to* devono essere "
"entrambi :term:`oggetti simili a bytes <bytes-like object>` e avere la "
"stessa lunghezza."

#: library/stdtypes.rst:2911
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Divide la sequenza alla prima occorrenza di *sep*, e restituisce una tupla a "
"3 elementi contenente la parte prima del separatore, il separatore stesso o "
"la sua copia bytearray, e la parte dopo il separatore. Se il separatore non "
"viene trovato, restituisce una tupla a 3 elementi contenente una copia della "
"sequenza originale, seguita da due oggetti vuoti bytes o bytearray."

#: library/stdtypes.rst:2975
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""
"Il separatore da cercare può essere qualsiasi :term:`oggetto simile a bytes "
"<bytes-like object>`."

#: library/stdtypes.rst:2924
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Restituisce una copia della sequenza con tutte le occorrenze della "
"sottosequenza *old* sostituite da *new*. Se viene specificato l'argomento "
"opzionale *count*, vengono sostituite solo le prime *count* occorrenze."

#: library/stdtypes.rst:2928
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"La sottosequenza da cercare e la sua sostituzione possono essere qualsiasi :"
"term:`oggetto simile a bytes <bytes-like object>`."

#: library/stdtypes.rst:2940
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Restituisce l'indice più alto nella sequenza dove si trova la sottosequenza "
"*sub*, tale che *sub* sia contenuto in ``s[start:end]``. Gli argomenti "
"opzionali *start* e *end* sono interpretati come nella notazione delle "
"slice. Restituisce ``-1`` in caso di fallimento."

#: library/stdtypes.rst:2955
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Come :meth:`~bytes.rfind` ma solleva :exc:`ValueError` quando la "
"sottosequenza *sub* non viene trovata."

#: library/stdtypes.rst:2968
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Divide la sequenza all'ultima occorrenza di *sep*, e restituisce una tupla a "
"3 elementi contenente la parte prima del separatore, il separatore stesso o "
"la sua copia bytearray, e la parte dopo il separatore. Se il separatore non "
"viene trovato, restituisce una tupla a 3 elementi contenente due oggetti "
"vuoti bytes o bytearray, seguiti da una copia della sequenza originale."

#: library/stdtypes.rst:2981
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Restituisce ``True`` se i dati binari iniziano con il *prefix* specificato, "
"altrimenti restituisce ``False``. *prefix* può essere anche una tupla di "
"prefissi da cercare. Con *start* opzionale, il test inizia a quella "
"posizione. Con *end* opzionale, smette di confrontare a quella posizione."

#: library/stdtypes.rst:2986
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Il/i prefisso/i da cercare possono essere qualsiasi :term:`oggetto simile a "
"bytes <bytes-like object>`."

#: library/stdtypes.rst:2992
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Restituisce una copia dell'oggetto bytes o bytearray dove tutti i bytes "
"presenti nell'argomento opzionale *delete* sono stati rimossi, e i bytes "
"rimanenti sono stati mappati attraverso la tabella di traduzione data, che "
"deve essere un oggetto bytes di lunghezza 256."

#: library/stdtypes.rst:2997
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Puoi usare il metodo :func:`bytes.maketrans` per creare una tabella di "
"traduzione."

#: library/stdtypes.rst:3000
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Imposta l'argomento *table* su ``None`` per traduzioni che eliminano solo i "
"caratteri::"

#: library/stdtypes.rst:3006
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* ora è supportato come argomento keyword."

#: library/stdtypes.rst:3010
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"I seguenti metodi su oggetti bytes e bytearray hanno comportamenti "
"predefiniti che assumono l'uso di formati binari compatibili con ASCII, ma "
"possono essere comunque utilizzati con dati binari arbitrari passando "
"argomenti appropriati. Nota che tutti i metodi bytearray in questa sezione "
"*non* operano in place, e invece producono nuovi oggetti."

#: library/stdtypes.rst:3019
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Restituisce una copia dell'oggetto centrato in una sequenza di lunghezza "
"*width*. L'imbottitura viene fatta usando il *fillbyte* specificato (il "
"predefinito è uno spazio ASCII). Per oggetti :class:`bytes`, la sequenza "
"originale viene restituita se *width* è minore o uguale a ``len(s)``."

#: library/stdtypes.rst:3033
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Restituisce una copia dell'oggetto giustificato a sinistra in una sequenza "
"di lunghezza *width*. L'imbottitura viene fatta usando il *fillbyte* "
"specificato (il predefinito è uno spazio ASCII). Per oggetti :class:`bytes`, "
"la sequenza originale viene restituita se *width* è minore o uguale a "
"``len(s)``."

#: library/stdtypes.rst:3047
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Restituisce una copia della sequenza con i bytes iniziali specificati "
"rimossi. L'argomento *chars* è una sequenza binaria che specifica il set di "
"valori dei byte da rimuovere - il nome si riferisce al fatto che questo "
"metodo è solitamente usato con caratteri ASCII. Se omesso o ``None``, "
"l'argomento *chars* predefinito è rimuovere gli spazi bianchi ASCII. "
"L'argomento *chars* non è un prefisso; piuttosto, tutte le combinazioni dei "
"suoi valori vengono rimosse::"

#: library/stdtypes.rst:3059
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"La sequenza binaria di valori byte da rimuovere può essere qualsiasi :term:"
"`oggetto simile a bytes <bytes-like object>`. Vedi :meth:`~bytes."
"removeprefix` per un metodo che rimuoverà una singola stringa prefisso "
"anziché tutti i caratteri di un set. Ad esempio::"

#: library/stdtypes.rst:3078
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Restituisce una copia dell'oggetto giustificato a destra in una sequenza di "
"lunghezza *width*. L'imbottitura viene fatta usando il *fillbyte* "
"specificato (il predefinito è uno spazio ASCII). Per oggetti :class:`bytes`, "
"la sequenza originale viene restituita se *width* è minore o uguale a "
"``len(s)``."

#: library/stdtypes.rst:3092
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Divide la sequenza binaria in sottosequenze dello stesso tipo, usando *sep* "
"come stringa delimitatore. Se viene specificato *maxsplit*, vengono "
"effettuate al massimo *maxsplit* divisioni, le ultime. Se *sep* non è "
"specificato o è ``None``, qualsiasi sottosequenza costituita esclusivamente "
"da spazi bianchi ASCII è un separatore. A parte per la divisione da destra, :"
"meth:`rsplit` si comporta come :meth:`split` che è descritto in dettaglio di "
"seguito."

#: library/stdtypes.rst:3103
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Restituisce una copia della sequenza con i bytes finali specificati rimossi. "
"L'argomento *chars* è una sequenza binaria che specifica il set di valori "
"dei byte da rimuovere - il nome si riferisce al fatto che questo metodo è "
"solitamente usato con caratteri ASCII. Se omesso o ``None``, l'argomento "
"*chars* predefinito è rimuovere gli spazi bianchi ASCII. L'argomento *chars* "
"non è un suffisso; piuttosto, tutte le combinazioni dei suoi valori vengono "
"rimosse::"

#: library/stdtypes.rst:3115
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"La sequenza binaria di valori byte da rimuovere può essere qualsiasi :term:"
"`oggetto simile a bytes <bytes-like object>`. Vedi :meth:`~bytes."
"removesuffix` per un metodo che rimuoverà una singola stringa suffisso "
"anziché tutti i caratteri di un set. Ad esempio::"

#: library/stdtypes.rst:3134
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Divide la sequenza binaria in sottosequenze dello stesso tipo, usando *sep* "
"come stringa delimitatore. Se *maxsplit* è dato e non negativo, vengono "
"effettuate al massimo *maxsplit* divisioni (quindi, la lista avrà al massimo "
"``maxsplit+1`` elementi). Se *maxsplit* non è specificato o è ``-1``, non "
"c'è limite al numero di divisioni (vengono effettuate tutte le possibili "
"divisioni)."

#: library/stdtypes.rst:3140
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"Se *sep* è dato, i delimitatori consecutivi non sono raggruppati insieme e "
"sono considerati delimitatori per sottosequenze vuote (ad esempio, ``b'1,,2'."
"split(b',')`` restituisce ``[b'1', b'', b'2']``). L'argomento *sep* può "
"consistere in una sequenza multibyte (ad esempio, ``b'1<>2<>3'."
"split(b'<>')`` restituisce ``[b'1', b'2', b'3']``). Divisione di una "
"sequenza vuota con un separatore specificato restituisce ``[b'']`` o "
"``[bytearray(b'')]`` a seconda del tipo di oggetto che viene diviso. "
"L'argomento *sep* può essere qualsiasi :term:`oggetto simile a bytes <bytes-"
"like object>`."

#: library/stdtypes.rst:3158
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Se *sep* non è specificato o è ``None``, viene applicato un diverso "
"algoritmo di divisione: le sequenze di spazi bianchi ASCII consecutivi sono "
"considerate come un singolo separatore, e il risultato non conterrà stringhe "
"vuote all'inizio o alla fine se la sequenza ha spazi bianchi iniziali o "
"finali. Pertanto, dividendo una sequenza vuota o una sequenza costituita "
"esclusivamente da spazi bianchi ASCII senza un separatore specificato si "
"ottiene ``[]``."

#: library/stdtypes.rst:3179
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Restituisce una copia della sequenza con i bytes iniziali e finali "
"specificati rimossi. L'argomento *chars* è una sequenza binaria che "
"specifica il set di valori dei byte da rimuovere - il nome si riferisce al "
"fatto che questo metodo è solitamente usato con caratteri ASCII. Se omesso o "
"``None``, l'argomento *chars* predefinito è rimuovere gli spazi bianchi "
"ASCII. L'argomento *chars* non è un prefisso o un suffisso; piuttosto, tutte "
"le combinazioni dei suoi valori vengono rimosse::"

#: library/stdtypes.rst:3192
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"La sequenza binaria di valori byte da rimuovere può essere qualsiasi :term:"
"`oggetto simile a bytes <bytes-like object>`."

#: library/stdtypes.rst:3201
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"I seguenti metodi sugli oggetti bytes e bytearray assumono l'uso di formati "
"binari compatibili con ASCII e non dovrebbero essere applicati a dati binari "
"arbitrari. Nota che tutti i metodi bytearray in questa sezione *non* operano "
"in place, e invece producono nuovi oggetti."

#: library/stdtypes.rst:3209
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Restituisce una copia della sequenza con ogni byte interpretato come un "
"carattere ASCII, e il primo byte capitalizzato e il resto in minuscolo. I "
"valori dei byte non ASCII vengono trasmessi senza modifiche."

#: library/stdtypes.rst:3222
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Restituisce una copia della sequenza dove tutti i caratteri ASCII tab sono "
"sostituiti da uno o più spazi ASCII, a seconda della colonna corrente e "
"della dimensione del tab fornita. Le posizioni della tabulazione si "
"verificano ogni *tabsize* byte (il valore predefinito è 8, dando le "
"posizioni della tabulazione alle colonne 0, 8, 16 e così via). Per espandere "
"la sequenza, la colonna corrente viene impostata a zero e la sequenza viene "
"esaminata byte per byte. Se il byte è un carattere tabulazione ASCII "
"(``b'\\t'``), uno o più spazi vengono inseriti nel risultato fino a quando "
"la colonna corrente è uguale alla prossima posizione di tabulazione. (Il "
"carattere tabulazione stesso non viene copiato.) Se il byte corrente è una "
"nuova riga ASCII (``b'\\n'``) o ritorno a capo (``b'\\r'``), viene copiato e "
"la colonna corrente viene reimpostata a zero. Qualsiasi altro valore di byte "
"viene copiato senza modifiche e la colonna corrente viene incrementata di "
"uno indipendentemente da come il valore del byte viene rappresentato quando "
"viene stampato::"

#: library/stdtypes.rst:3250
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Restituisce ``True`` se tutti i byte nella sequenza sono caratteri "
"alfabetici ASCII o cifre decimali ASCII e la sequenza non è vuota, ``False`` "
"altrimenti. I caratteri alfabetici ASCII sono quei valori di byte nella "
"sequenza ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Le "
"cifre decimali ASCII sono quei valori di byte nella sequenza "
"``b'0123456789'``."

#: library/stdtypes.rst:3267
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Restituisce ``True`` se tutti i byte nella sequenza sono caratteri "
"alfabetici ASCII e la sequenza non è vuota, ``False`` altrimenti. I "
"caratteri alfabetici ASCII sono quei valori di byte nella sequenza "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: library/stdtypes.rst:3283
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Restituisce ``True`` se la sequenza è vuota o se tutti i byte nella sequenza "
"sono ASCII, ``False`` altrimenti. I byte ASCII sono nell'intervallo 0-0x7F."

#: library/stdtypes.rst:3293
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Restituisce ``True`` se tutti i byte nella sequenza sono cifre decimali "
"ASCII e la sequenza non è vuota, ``False`` altrimenti. Le cifre decimali "
"ASCII sono quei valori di byte nella sequenza ``b'0123456789'``."

#: library/stdtypes.rst:3308
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Restituisce ``True`` se c'è almeno un carattere minuscolo ASCII nella "
"sequenza e nessun carattere maiuscolo ASCII, ``False`` altrimenti."

#: library/stdtypes.rst:3360 library/stdtypes.rst:3426
#: library/stdtypes.rst:3495
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"I caratteri minuscoli ASCII sono quei valori di byte nella sequenza "
"``b'abcdefghijklmnopqrstuvwxyz'``. I caratteri maiuscoli ASCII sono quei "
"valori di byte nella sequenza ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: library/stdtypes.rst:3326
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Restituisce ``True`` se tutti i byte nella sequenza sono spazi bianchi ASCII "
"e la sequenza non è vuota, ``False`` altrimenti. I caratteri di spazio "
"bianco ASCII sono quei valori di byte nella sequenza ``b' "
"\\t\\n\\r\\x0b\\f'`` (spazio, tabulazione, nuova riga, ritorno a capo, "
"tabulazione verticale, form feed)."

#: library/stdtypes.rst:3335
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Restituisce ``True`` se la sequenza è in formato ASCII \"titlecase\" e la "
"sequenza non è vuota, ``False`` altrimenti. Vedi :meth:`bytes.title` per "
"maggiori dettagli sulla definizione di \"titlecase\"."

#: library/stdtypes.rst:3350
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Restituisce ``True`` se c'è almeno un carattere alfabetico ASCII maiuscolo "
"nella sequenza e nessun carattere ASCII minuscolo, ``False`` altrimenti."

#: library/stdtypes.rst:3368
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Restituisce una copia della sequenza con tutti i caratteri ASCII maiuscoli "
"convertiti nei loro corrispondenti caratteri minuscoli."

#: library/stdtypes.rst:3393
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Restituisce un elenco delle linee nella sequenza binaria, suddividendo ai "
"confini delle linee ASCII. Questo metodo utilizza l'approccio delle :term:"
"`universal newlines` per dividere le linee. Le interruzioni di linea non "
"sono incluse nell'elenco risultante a meno che *keepends* non sia fornito e "
"impostato su vero."

#: library/stdtypes.rst:3405
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"A differenza di :meth:`~bytes.split` quando viene dato un delimitatore di "
"stringa *sep*, questo metodo restituisce un elenco vuoto per la stringa "
"vuota, e un'interruzione di linea terminale non produce una linea extra::"

#: library/stdtypes.rst:3418
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Restituisce una copia della sequenza con tutti i caratteri ASCII minuscoli "
"convertiti nei loro corrispondenti caratteri maiuscoli e viceversa."

#: library/stdtypes.rst:3430
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"A differenza di :func:`str.swapcase()`, è sempre il caso che ``bin."
"swapcase().swapcase() == bin`` per le versioni binarie. Le conversioni di "
"maiuscole e minuscole sono simmetriche in ASCII, anche se ciò non è "
"generalmente vero per punti di codice Unicode arbitrari."

#: library/stdtypes.rst:3444
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Restituisce una versione in formato \"titlecase\" della sequenza binaria in "
"cui le parole iniziano con un carattere ASCII maiuscolo e i rimanenti "
"caratteri sono minuscoli. I valori di byte senza distinzione di maiuscole e "
"minuscole non vengono modificati."

#: library/stdtypes.rst:3453
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"I caratteri ASCII minuscoli sono quei valori di byte nella sequenza "
"``b'abcdefghijklmnopqrstuvwxyz'``. I caratteri ASCII maiuscoli sono quei "
"valori di byte nella sequenza ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Tutti gli "
"altri valori di byte sono senza distinzione di maiuscole e minuscole."

#: library/stdtypes.rst:3466
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Una soluzione alternativa per gli apostrofi può essere costruita utilizzando "
"espressioni regolari::"

#: library/stdtypes.rst:3487
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Restituisce una copia della sequenza con tutti i caratteri ASCII minuscoli "
"convertiti nei loro corrispondenti caratteri maiuscoli."

#: library/stdtypes.rst:3508
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Restituisce una copia della sequenza riempita a sinistra con i caratteri "
"ASCII ``b'0'`` per creare una sequenza della lunghezza *width*. Un prefisso "
"di segno principale (``b'+'``/ ``b'-'``) viene gestito inserendo il padding "
"*dopo* il carattere del segno anziché prima. Per gli oggetti :class:`bytes`, "
"la sequenza originale viene restituita se *width* è inferiore o uguale a "
"``len(seq)``."

#: library/stdtypes.rst:3530
msgid "``printf``-style Bytes Formatting"
msgstr "Formattazione Bytes stile ``printf``"

#: library/stdtypes.rst:3547
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Le operazioni di formattazione descritte qui mostrano una varietà di "
"stranezze che portano a numerosi errori comuni (come la visualizzazione "
"errata di tuple e dizionari). Se il valore da stampare potrebbe essere una "
"tupla o un dizionario, racchiudilo in una tupla."

#: library/stdtypes.rst:3552
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Gli oggetti Bytes (``bytes``/``bytearray``) hanno un'operazione integrata "
"unica: l'operatore ``%`` (modulo). Questo è anche noto come operatore di "
"*formattazione* o *interpolazione* dei bytes. Dato ``format % values`` (dove "
"*format* è un oggetto bytes), le specifiche di conversione ``%`` in *format* "
"sono sostituite con uno o più elementi di *values*. L'effetto è simile "
"all'uso della funzione :c:func:`sprintf` nel linguaggio C."

#: library/stdtypes.rst:3559
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Se *format* richiede un singolo argomento, *values* può essere un singolo "
"oggetto non-tuple. [5]_ Altrimenti, *values* deve essere una tupla con "
"esattamente il numero di elementi specificati dall'oggetto bytes di formato, "
"o un singolo oggetto di mappatura (ad esempio, un dizionario)."

#: library/stdtypes.rst:3593
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Quando l'argomento a destra è un dizionario (o un altro tipo di mappatura), "
"allora i formati nell'oggetto bytes *devono* includere una chiave di "
"mappatura tra parentesi in quel dizionario inserita immediatamente dopo il "
"carattere ``'%'``. La chiave di mappatura seleziona il valore da formattare "
"dalla mappatura. Ad esempio:"

#: library/stdtypes.rst:3667
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Byte singolo (accetta oggetti interi o byte singoli)."

#: library/stdtypes.rst:3670
msgid "``'b'``"
msgstr "``'b'``"

#: library/stdtypes.rst:3670
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`~object.__bytes__`)."
msgstr ""
"Bytes (qualsiasi oggetto che segue il :ref:`buffer protocol <bufferobjects>` "
"o ha :meth:`~object.__bytes__`)."

#: library/stdtypes.rst:3674
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s'`` è un alias per ``'b'`` e dovrebbe essere usato solo per basi di "
"codice Python2/3."

#: library/stdtypes.rst:3677
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Bytes (converte qualsiasi oggetto Python utilizzando ``repr(obj)."
"encode('ascii', 'backslashreplace')``)."

#: library/stdtypes.rst:3680
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` è un alias per ``'a'`` e dovrebbe essere usato solo per basi di "
"codice Python2/3."

#: library/stdtypes.rst:3680
msgid "\\(7)"
msgstr "\\(7)"

#: library/stdtypes.rst:3715
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` è deprecato, ma non verrà rimosso durante la serie 3.x."

#: library/stdtypes.rst:3718
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` è deprecato, ma non verrà rimosso durante la serie 3.x."

#: library/stdtypes.rst:3730
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Aggiunta della formattazione % a bytes e bytearray"

#: library/stdtypes.rst:3737
msgid "Memory Views"
msgstr "Memory Views"

#: library/stdtypes.rst:3739
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Gli oggetti :class:`memoryview` permettono al codice Python di accedere ai "
"dati interni di un oggetto che supporta il :ref:`buffer protocol "
"<bufferobjects>` senza copiarli."

#: library/stdtypes.rst:3745
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"Crea un :class:`memoryview` che fa riferimento a *object*. *object* deve "
"supportare il buffer protocol. Gli oggetti integrati che supportano il "
"buffer protocol includono :class:`bytes` e :class:`bytearray`."

#: library/stdtypes.rst:3749
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
"Un :class:`memoryview` ha la nozione di *elemento*, che è l'unità di memoria "
"atomica gestita dall'*object* originario. Per molti tipi semplici come :"
"class:`bytes` e :class:`bytearray`, un elemento è un byte singolo, ma altri "
"tipi come :class:`array.array` possono avere elementi più grandi."

#: library/stdtypes.rst:3754
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which "
"is the nested list representation of the view. If ``view.ndim = 1``, this is "
"equal to the number of elements in the view."
msgstr ""
"``len(view)`` è uguale alla lunghezza di :class:`~memoryview.tolist`, che è "
"la rappresentazione dell'elenco nidificato della vista. Se ``view.ndim = "
"1``, questo è uguale al numero di elementi nella vista."

#: library/stdtypes.rst:3758
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr ""
"Se ``view.ndim == 0``, ``len(view)`` ora solleva :exc:`TypeError` invece di "
"restituire 1."

#: library/stdtypes.rst:3761
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"L'attributo :class:`~memoryview.itemsize` ti fornirà il numero di byte in un "
"singolo elemento."

#: library/stdtypes.rst:3764
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"Un :class:`memoryview` supporta slicing e indicizzazioni per esporre i suoi "
"dati. Lo slicing monodimensionale risulterà in una sotto-vista::"

#: library/stdtypes.rst:3777
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Se :class:`~memoryview.format` è uno degli specificatori di formato nativi "
"del modulo :mod:`struct`, l'indicizzazione con un intero o una tupla di "
"interi è anche supportata e restituisce un singolo *elemento* con il tipo "
"corretto. Le memoryview monodimensionali possono essere indicizzate con un "
"intero o una tupla di un intero. Le memoryview multidimensionali possono "
"essere indicizzate con tuple di esattamente *ndim* interi dove *ndim* è il "
"numero di dimensioni. Le memoryview zero-dimensionali possono essere "
"indicizzate con la tupla vuota."

#: library/stdtypes.rst:3786
msgid "Here is an example with a non-byte format::"
msgstr "Ecco un esempio con un formato non-byte::"

#: library/stdtypes.rst:3798
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Se l'oggetto sottostante è scrivibile, la memoryview supporta l'assegnazione "
"di slice monodimensionale. Non è permesso il ridimensionamento::"

#: library/stdtypes.rst:3819
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""
"Le memoryview monodimensionali di tipi :term:`hashable` (di sola lettura) "
"con formati 'B', 'b' o 'c' sono anche hashable. L'hash è definito come "
"``hash(m) == hash(m.tobytes())``::"

#: library/stdtypes.rst:3831
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""
"Le memoryview monodimensionali possono ora essere slice. Le memoryview "
"monodimensionali con formati 'B', 'b' o 'c' sono ora :term:`hashable`."

#: library/stdtypes.rst:3835
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"memoryview è ora registrato automaticamente con :class:`collections.abc."
"Sequence`"

#: library/stdtypes.rst:3839
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "le memoryview possono ora essere indicizzate con tuple di interi."

#: library/stdtypes.rst:3842
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` ha diversi metodi:"

#: library/stdtypes.rst:3846
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Una memoryview e un esportatore :pep:`3118` sono uguali se le loro forme "
"sono equivalenti e se tutti i valori corrispondenti sono uguali quando i "
"rispettivi codici di formato degli operandi sono interpretati utilizzando la "
"sintassi :mod:`struct`."

#: library/stdtypes.rst:3850
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Per il sottoinsieme di stringhe di formato :mod:`struct` attualmente "
"supportato da :meth:`tolist`, ``v`` e ``w`` sono uguali se ``v.tolist() == w."
"tolist()``::"

#: library/stdtypes.rst:3869
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Se una delle stringhe di formato non è supportata dal modulo :mod:`struct`, "
"allora gli oggetti saranno sempre considerati diversi (anche se le stringhe "
"di formato e i contenuti del buffer sono identici)::"

#: library/stdtypes.rst:3885
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Si noti che, come per i numeri in virgola mobile, ``v is w`` non implica ``v "
"== w`` per gli oggetti memoryview."

#: library/stdtypes.rst:3888
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Le versioni precedenti confrontavano la memoria grezza senza considerare il "
"formato degli elementi e la struttura dell'array logico."

#: library/stdtypes.rst:3894
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Restituisce i dati nel buffer come una stringa di byte. Questo è equivalente "
"a chiamare il costruttore :class:`bytes` sulla memoryview. ::"

#: library/stdtypes.rst:3903
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Per gli array non contigui il risultato è uguale alla rappresentazione "
"dell'elenco appiattito con tutti gli elementi convertiti in byte. :meth:"
"`tobytes` supporta tutte le stringhe di formato, comprese quelle che non "
"sono nella sintassi del modulo :mod:`struct`."

#: library/stdtypes.rst:3908
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*order* può essere {'C', 'F', 'A'}. Quando *order* è 'C' o 'F', i dati "
"dell'array originale sono convertiti in ordine C o Fortran. Per le viste "
"contigue, 'A' restituisce una copia esatta della memoria fisica. In "
"particolare, l'ordine Fortran in memoria viene preservato. Per le viste non "
"contigue, i dati sono prima convertiti in C. *order=None* è equivalente a "
"*order='C'*."

#: library/stdtypes.rst:3917
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Restituisce un oggetto stringa contenente due cifre esadecimali per ogni "
"byte nel buffer. ::"

#: library/stdtypes.rst:3926
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Simile a :meth:`bytes.hex`, :meth:`memoryview.hex` supporta ora i parametri "
"opzionali *sep* e *bytes_per_sep* per inserire separatori tra i byte "
"nell'output esadecimale."

#: library/stdtypes.rst:3933
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Restituisce i dati nel buffer come una lista di elementi. ::"

#: library/stdtypes.rst:3943
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` supporta ora tutti i formati nativi a singolo carattere nella "
"sintassi del modulo :mod:`struct` nonché rappresentazioni multidimensionali."

#: library/stdtypes.rst:3950
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Restituisce una versione di sola lettura dell'oggetto memoryview. L'oggetto "
"memoryview originale rimane invariato. ::"

#: library/stdtypes.rst:3969
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Rilascia il buffer sottostante esposto dall'oggetto memoryview. Molti "
"oggetti prendono azioni speciali quando una vista è mantenuta su di essi (ad "
"esempio, un :class:`bytearray` temporaneamente vieterebbe il "
"ridimensionamento); quindi, chiamare release() è utile per rimuovere queste "
"restrizioni (e liberare eventuali risorse sospese) il più presto possibile."

#: library/stdtypes.rst:3975
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"Dopo che questo metodo è stato chiamato, qualsiasi ulteriore operazione "
"sulla vista solleva un'eccezione :class:`ValueError` (eccetto :meth:"
"`release()` stesso che può essere chiamato più volte)::"

#: library/stdtypes.rst:3986
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Il protocollo di gestione del contesto può essere utilizzato per un effetto "
"simile, usando l'istruzione ``with``::"

#: library/stdtypes.rst:4002
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Converte un memoryview in un nuovo formato o forma. *shape* di default è "
"``[byte_length//new_itemsize]``, il che significa che la vista risultante "
"sarà unidimensionale. Il valore restituito è un nuovo memoryview, ma il "
"buffer stesso non è copiato. I cast supportati sono 1D -> C-:term:"
"`contiguous` e C-contiguous -> 1D."

#: library/stdtypes.rst:4008
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length. "
"Note that all byte lengths may depend on the operating system."
msgstr ""
"Il formato di destinazione è limitato a un formato nativo a singolo elemento "
"nella sintassi del modulo :mod:`struct`. Uno dei formati deve essere un "
"formato byte ('B', 'b' o 'c'). La lunghezza in byte del risultato deve "
"essere uguale alla lunghezza originale. Nota che tutte le lunghezze in byte "
"possono dipendere dal sistema operativo."

#: library/stdtypes.rst:4014
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Converte 1D/long in 1D/unsigned bytes::"

#: library/stdtypes.rst:4037
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Converte 1D/unsigned bytes in 1D/char::"

#: library/stdtypes.rst:4050
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Converte 1D/bytes in 3D/ints in 1D/signed char::"

#: library/stdtypes.rst:4076
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Converte 1D/unsigned long in 2D/unsigned long::"

#: library/stdtypes.rst:4090
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Il formato di origine non è più limitato quando si converte in una vista "
"byte."

#: library/stdtypes.rst:4093
msgid "There are also several readonly attributes available:"
msgstr "Sono disponibili anche diversi attributi di sola lettura:"

#: library/stdtypes.rst:4097
msgid "The underlying object of the memoryview::"
msgstr "L'oggetto sottostante del memoryview::"

#: library/stdtypes.rst:4108
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Questo è lo "
"spazio in byte che l'array utilizzarebbe in una rappresentazione contigua. "
"Non necessariamente uguale a ``len(m)``::"

#: library/stdtypes.rst:4127
msgid "Multi-dimensional arrays::"
msgstr "Array multidimensionali::"

#: library/stdtypes.rst:4144
msgid "A bool indicating whether the memory is read only."
msgstr "Un bool che indica se la memoria è di sola lettura."

#: library/stdtypes.rst:4148
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Una stringa contenente il formato (nello stile del modulo :mod:`struct`) per "
"ogni elemento nella vista. Un memoryview può essere creato da esportatori "
"con stringhe di formato arbitrario, ma alcuni metodi (es.: :meth:`tolist`) "
"sono limitati ai formati a singolo elemento nativi."

#: library/stdtypes.rst:4153
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"Il formato ``'B'`` viene ora gestito secondo la sintassi del modulo struct. "
"Ciò significa che ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

#: library/stdtypes.rst:4159
msgid "The size in bytes of each element of the memoryview::"
msgstr "La dimensione in byte di ogni elemento del memoryview::"

#: library/stdtypes.rst:4172
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Un intero che indica quante dimensioni di un array multidimensionale la "
"memoria rappresenta."

#: library/stdtypes.rst:4177
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Una tupla di numeri interi della lunghezza di :attr:`ndim` che indica la "
"forma della memoria come un array N-dimensionale."

#: library/stdtypes.rst:4188
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Una tupla vuota invece di ``None`` quando ndim = 0."

#: library/stdtypes.rst:4185
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Una tupla di numeri interi della lunghezza di :attr:`ndim` che indica la "
"dimensione in byte per accedere a ogni elemento per ciascuna dimensione "
"dell'array."

#: library/stdtypes.rst:4193
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Usato internamente per array in stile PIL. Il valore è solo informativo."

#: library/stdtypes.rst:4197
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Un bool che indica se la memoria è C-:term:`contiguous`."

#: library/stdtypes.rst:4203
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Un bool che indica se la memoria è Fortran :term:`contiguous`."

#: library/stdtypes.rst:4209
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Un bool che indica se la memoria è :term:`contiguous`."

#: library/stdtypes.rst:4217
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Tipi di Insiemi --- :class:`set`, :class:`frozenset`"

#: library/stdtypes.rst:4221
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Un oggetto :dfn:`set` è una collezione non ordinata di oggetti distinti :"
"term:`hashable`. Usati comunemente per test di appartenenza, rimozione di "
"duplicati da una sequenza e operazioni matematiche come intersezione, "
"unione, differenza e differenza simmetrica. (Per altri contenitori vedi le "
"classi integrate :class:`dict`, :class:`list` e :class:`tuple`, e il modulo :"
"mod:`collections`.)"

#: library/stdtypes.rst:4228
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Come altre collezioni, gli insiemi supportano ``x in set``, ``len(set)`` e "
"``for x in set``. Essendo una collezione non ordinata, gli insiemi non "
"tengono traccia della posizione degli elementi o dell'ordine di inserimento. "
"Di conseguenza, gli insiemi non supportano indicizzazione, slicing o altro "
"comportamento simile a una sequenza."

#: library/stdtypes.rst:4233
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Attualmente esistono due tipi di insiemi incorporati, :class:`set` e :class:"
"`frozenset`. Il tipo :class:`set` è mutabile --- il contenuto può essere "
"cambiato usando metodi come :meth:`~set.add` e :meth:`~set.remove`. Poiché è "
"mutabile, non ha un valore di hash e non può essere utilizzato come chiave "
"di un dizionario o come elemento di un altro insieme. Il tipo :class:"
"`frozenset` è immutabile e :term:`hashable` --- i suoi contenuti non possono "
"essere alterati dopo la sua creazione; può quindi essere utilizzato come "
"chiave di un dizionario o come elemento di un altro insieme."

#: library/stdtypes.rst:4241
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Gli insiemi non vuoti (non i frozenset) possono essere creati mettendo un "
"elenco di elementi separati da virgole tra parentesi graffe, per esempio: "
"``{'jack', 'sjoerd'}``, oltre al costruttore :class:`set`."

#: library/stdtypes.rst:4245
msgid "The constructors for both classes work the same:"
msgstr "I costruttori per entrambe le classi funzionano allo stesso modo:"

#: library/stdtypes.rst:4250
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Restituisce un nuovo oggetto set o frozenset i cui elementi sono presi da "
"*iterable*. Gli elementi di un insieme devono essere :term:`hashable`. Per "
"rappresentare insiemi di insiemi, gli insiemi interni devono essere oggetti :"
"class:`frozenset`. Se *iterable* non è specificato, viene restituito un "
"nuovo insieme vuoto."

#: library/stdtypes.rst:4256
msgid "Sets can be created by several means:"
msgstr "Gli insiemi possono essere creati in diversi modi:"

#: library/stdtypes.rst:4258
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Usa un elenco di elementi separati da virgole tra parentesi graffe: "
"``{'jack', 'sjoerd'}``"

#: library/stdtypes.rst:4259
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Usa una comprensione dell'insieme: ``{c for c in 'abracadabra' if c not in "
"'abc'}``"

#: library/stdtypes.rst:4260
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Usa il costruttore di tipo: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"

#: library/stdtypes.rst:4262
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Le istanze di :class:`set` e :class:`frozenset` forniscono le seguenti "
"operazioni:"

#: library/stdtypes.rst:4267
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr ""
"Restituisce il numero di elementi nell'insieme *s* (cardinalità di *s*)."

#: library/stdtypes.rst:4271
msgid "Test *x* for membership in *s*."
msgstr "Verifica l'appartenenza di *x* in *s*."

#: library/stdtypes.rst:4275
msgid "Test *x* for non-membership in *s*."
msgstr "Verifica la non appartenenza di *x* in *s*."

#: library/stdtypes.rst:4279
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Restituisce ``True`` se l'insieme non ha elementi in comune con *other*. Gli "
"insiemi sono disgiunti se e solo se la loro intersezione è l'insieme vuoto."

#: library/stdtypes.rst:4285
msgid "Test whether every element in the set is in *other*."
msgstr "Verifica se ogni elemento nell'insieme è in *other*."

#: library/stdtypes.rst:4289
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Verifica se l'insieme è un sottoinsieme proprio di *other*, cioè, ``set <= "
"other e set != other``."

#: library/stdtypes.rst:4295
msgid "Test whether every element in *other* is in the set."
msgstr "Verificare se ogni elemento in *other* è presente nell'insieme."

#: library/stdtypes.rst:4299
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Verificare se l'insieme è un superinsieme proprio di *other*, cioè ``set >= "
"other and set != other``."

#: library/stdtypes.rst:4305
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Restituire un nuovo insieme con elementi dall'insieme e tutti gli altri."

#: library/stdtypes.rst:4310
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Restituire un nuovo insieme con elementi comuni all'insieme e a tutti gli "
"altri."

#: library/stdtypes.rst:4315
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Restituire un nuovo insieme con elementi presenti nell'insieme ma non negli "
"altri."

#: library/stdtypes.rst:4320
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Restituire un nuovo insieme con elementi presenti nell'insieme o in *other* "
"ma non in entrambi."

#: library/stdtypes.rst:4324
msgid "Return a shallow copy of the set."
msgstr "Restituire una copia superficiale dell'insieme."

#: library/stdtypes.rst:4327
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Nota, le versioni non operatore dei metodi :meth:`union`, :meth:"
"`intersection`, :meth:`difference`, :meth:`symmetric_difference`, :meth:"
"`issubset` e :meth:`issuperset` accettano qualsiasi iterabile come "
"argomento. Al contrario, le loro controparti basate su operatori richiedono "
"che i loro argomenti siano insiemi. Questo esclude costruzioni inclini "
"all'errore come ``set('abc') & 'cbs'`` a favore di ``set('abc')."
"intersection('cbs')`` più leggibile."

#: library/stdtypes.rst:4334
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Sia :class:`set` che :class:`frozenset` supportano confronti tra insiemi. "
"Due insiemi sono uguali se e solo se ogni elemento di ciascun insieme è "
"contenuto nell'altro (ciascuno è un sottoinsieme dell'altro). Un insieme è "
"minore di un altro insieme se e solo se il primo insieme è un sottoinsieme "
"proprio del secondo insieme (è un sottoinsieme, ma non è uguale). Un insieme "
"è maggiore di un altro insieme se e solo se il primo insieme è un "
"superinsieme proprio del secondo insieme (è un superinsieme, ma non è "
"uguale)."

#: library/stdtypes.rst:4341
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Le istanze di :class:`set` sono confrontate con le istanze di :class:"
"`frozenset` basandosi sui loro membri. Ad esempio, ``set('abc') == "
"frozenset('abc')`` restituisce ``True`` e anche ``set('abc') in "
"set([frozenset('abc')])``."

#: library/stdtypes.rst:4345
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"I confronti di sottoinsieme e uguaglianza non si generalizzano a una "
"funzione di ordinamento totale. Ad esempio, due insiemi non vuoti e "
"disgiunti non sono uguali e non sono sottoinsiemi l'uno dell'altro, quindi "
"*tutti* i seguenti restituiscono ``False``: ``a<b``, ``a==b`` o ``a>b``."

#: library/stdtypes.rst:4350
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Poiché gli insiemi definiscono solo un ordinamento parziale (relazioni di "
"sottoinsieme), l'output del metodo :meth:`list.sort` è indefinito per le "
"liste di insiemi."

#: library/stdtypes.rst:4353
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Gli elementi dell'insieme, come le chiavi del dizionario, devono essere :"
"term:`hashable`."

#: library/stdtypes.rst:4355
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Le operazioni binarie che mescolano istanze di :class:`set` con :class:"
"`frozenset` restituiscono il tipo del primo operando. Ad esempio: "
"``frozenset('ab') | set('bc')`` restituisce un'istanza di :class:`frozenset`."

#: library/stdtypes.rst:4359
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"La seguente tabella elenca le operazioni disponibili per :class:`set` che "
"non si applicano alle istanze immutabili di :class:`frozenset`:"

#: library/stdtypes.rst:4365
msgid "Update the set, adding elements from all others."
msgstr "Aggiornare l'insieme, aggiungendo elementi da tutti gli altri."

#: library/stdtypes.rst:4370
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Aggiornare l'insieme, mantenendo solo gli elementi presenti in esso e in "
"tutti gli altri."

#: library/stdtypes.rst:4375
msgid "Update the set, removing elements found in others."
msgstr "Aggiornare l'insieme, rimuovendo gli elementi trovati negli altri."

#: library/stdtypes.rst:4380
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Aggiornare l'insieme, mantenendo solo gli elementi presenti in un insieme o "
"nell'altro, ma non in entrambi."

#: library/stdtypes.rst:4384
msgid "Add element *elem* to the set."
msgstr "Aggiungere l'elemento *elem* all'insieme."

#: library/stdtypes.rst:4388
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Rimuovere l'elemento *elem* dall'insieme. Solleva :exc:`KeyError` se *elem* "
"non è contenuto nell'insieme."

#: library/stdtypes.rst:4393
msgid "Remove element *elem* from the set if it is present."
msgstr "Rimuovere l'elemento *elem* dall'insieme, se presente."

#: library/stdtypes.rst:4397
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Rimuovere e restituire un elemento arbitrario dall'insieme. Solleva :exc:"
"`KeyError` se l'insieme è vuoto."

#: library/stdtypes.rst:4402
msgid "Remove all elements from the set."
msgstr "Rimuovere tutti gli elementi dall'insieme."

#: library/stdtypes.rst:4405
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Nota, le versioni non operatore dei metodi :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update` e :meth:"
"`symmetric_difference_update` accettano qualsiasi iterabile come argomento."

#: library/stdtypes.rst:4410
msgid ""
"Note, the *elem* argument to the :meth:`~object.__contains__`, :meth:"
"`remove`, and :meth:`discard` methods may be a set.  To support searching "
"for an equivalent frozenset, a temporary one is created from *elem*."
msgstr ""
"Nota, l'argomento *elem* per i metodi :meth:`~object.__contains__`, :meth:"
"`remove` e :meth:`discard` può essere un insieme. Per supportare la ricerca "
"di un frozenset equivalente, uno temporaneo viene creato da *elem*."

#: library/stdtypes.rst:4419
msgid "Mapping Types --- :class:`dict`"
msgstr "Tipi di Mapping --- :class:`dict`"

#: library/stdtypes.rst:4429
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Un oggetto :term:`mapping` mappa valori :term:`hashable` a oggetti "
"arbitrari. Le mappature sono oggetti mutabili. Attualmente esiste solo un "
"tipo standard di mappatura, il :dfn:`dizionario`. (Per altri contenitori, "
"vedere le classi incorporate :class:`list`, :class:`set` e :class:`tuple`, e "
"il modulo :mod:`collections`.)"

#: library/stdtypes.rst:4435
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"Le chiavi di un dizionario sono valori *quasi* arbitrari. Valori che non "
"sono :term:`hashable`, cioè valori che contengono liste, dizionari o altri "
"tipi mutabili (che sono comparati per valore anziché per identità "
"dell'oggetto) non possono essere usati come chiavi. Valori che sono "
"comparati come uguali (come ``1``, ``1.0`` e ``True``) possono essere usati "
"in modo intercambiabile per indicizzare la stessa voce del dizionario."

#: library/stdtypes.rst:4446
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Restituire un nuovo dizionario inizializzato da un argomento posizionale "
"opzionale e un insieme possibilmente vuoto di argomenti chiave-valore."

#: library/stdtypes.rst:4449
msgid "Dictionaries can be created by several means:"
msgstr "I dizionari possono essere creati con diversi metodi:"

#: library/stdtypes.rst:4451
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Utilizzare un elenco separato da virgole di coppie ``chiave: valore`` tra "
"parentesi graffe: ``{'jack': 4098, 'sjoerd': 4127}`` o ``{4098: 'jack', "
"4127: 'sjoerd'}``"

#: library/stdtypes.rst:4453
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""
"Usare una comprensione del dizionario: ``{}``, ``{x: x ** 2 per x in "
"range(10)}``"

#: library/stdtypes.rst:4454
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Utilizzare il costruttore di tipi: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"

#: library/stdtypes.rst:4457
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Se non viene fornito alcun argomento posizionale, viene creato un dizionario "
"vuoto. Se viene fornito un argomento posizionale ed è un oggetto di "
"mappatura, viene creato un dizionario con le stesse coppie chiave-valore "
"dell'oggetto di mappatura. Altrimenti, l'argomento posizionale deve essere "
"un oggetto :term:`iterable`. Ogni elemento dell'iterabile deve essere esso "
"stesso un iterabile con esattamente due oggetti. Il primo oggetto di ciascun "
"elemento diventa una chiave nel nuovo dizionario e il secondo oggetto il "
"valore corrispondente. Se una chiave si presenta più di una volta, l'ultimo "
"valore per quella chiave diventa il valore corrispondente nel nuovo "
"dizionario."

#: library/stdtypes.rst:4467
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Se vengono forniti argomenti chiave-valore, gli argomenti chiave-valore e i "
"loro valori vengono aggiunti al dizionario creato dall'argomento "
"posizionale. Se una chiave aggiunta è già presente, il valore dall'argomento "
"chiave-valore sostituisce il valore dall'argomento posizionale."

#: library/stdtypes.rst:4472
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Per illustrare, i seguenti esempi restituiscono tutti un dizionario uguale a "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

#: library/stdtypes.rst:4484
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Fornire argomenti chiave-valore come nel primo esempio funziona solo per "
"chiavi che sono identificatori Python validi. Altrimenti, è possibile "
"utilizzare qualsiasi chiave valida."

#: library/stdtypes.rst:4488
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Queste sono le operazioni che i dizionari supportano (e che quindi, anche i "
"tipi di mappatura personalizzati dovrebbero supportare):"

#: library/stdtypes.rst:4493
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Restituire un elenco di tutte le chiavi utilizzate nel dizionario *d*."

#: library/stdtypes.rst:4497
msgid "Return the number of items in the dictionary *d*."
msgstr "Restituire il numero di voci nel dizionario *d*."

#: library/stdtypes.rst:4501
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Restituire la voce di *d* con chiave *key*. Solleva un'eccezione :exc:"
"`KeyError` se *key* non è nella mappa."

#: library/stdtypes.rst:4506
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Se una sottoclasse di dict definisce un metodo :meth:`__missing__` e *key* "
"non è presente, l'operazione ``d[key]`` chiama quel metodo con la chiave "
"*key* come argomento. L'operazione ``d[key]`` quindi restituisce o solleva "
"qualunque cosa venga restituita o sollevata dalla chiamata "
"``__missing__(key)``. Nessun'altra operazione o metodo invoca :meth:"
"`__missing__`. Se :meth:`__missing__` non è definito, viene sollevata "
"un'eccezione :exc:`KeyError`. :meth:`__missing__` deve essere un metodo; non "
"può essere una variabile di istanza::"

#: library/stdtypes.rst:4525
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"L'esempio sopra mostra parte dell'implementazione di :class:`collections."
"Counter`. Un diverso metodo ``__missing__`` è utilizzato da :class:"
"`collections.defaultdict`."

#: library/stdtypes.rst:4531
msgid "Set ``d[key]`` to *value*."
msgstr "Impostare ``d[key]`` su *value*."

#: library/stdtypes.rst:4535
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Rimuovere ``d[key]`` da *d*. Solleva una :exc:`KeyError` se *key* non è "
"nella mappa."

#: library/stdtypes.rst:4540
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Restituire ``True`` se *d* ha una chiave *key*, altrimenti ``False``."

#: library/stdtypes.rst:4544
msgid "Equivalent to ``not key in d``."
msgstr "Equivalente a ``not key in d``."

#: library/stdtypes.rst:4548
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Restituire un iteratore sulle chiavi del dizionario. Questo è un "
"collegamento a ``iter(d.keys())``."

#: library/stdtypes.rst:4553
msgid "Remove all items from the dictionary."
msgstr "Rimuovere tutte le voci dal dizionario."

#: library/stdtypes.rst:4557
msgid "Return a shallow copy of the dictionary."
msgstr "Restituisce una copia superficiale del dizionario."

#: library/stdtypes.rst:4561
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Crea un nuovo dizionario con chiavi da *iterable* e valori impostati su "
"*value*."

#: library/stdtypes.rst:4563
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` è un metodo di classe che restituisce un nuovo dizionario. "
"*value* predefinito è ``None``. Tutti i valori si riferiscono a una singola "
"istanza, quindi generalmente non ha senso che *value* sia un oggetto "
"mutabile come una lista vuota. Per ottenere valori distinti, utilizzare "
"invece una :ref:`dict comprehension <dict>`."

#: library/stdtypes.rst:4571
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Restituisce il valore per *key* se *key* è nel dizionario, altrimenti "
"*default*. Se *default* non è fornito, predefinito è ``None``, in modo che "
"questo metodo non sollevi mai una :exc:`KeyError`."

#: library/stdtypes.rst:4577
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Restituisce una nuova vista degli elementi del dizionario (coppie ``(key, "
"value)``). Vedi la :ref:`documentazione degli oggetti view <dict-views>`."

#: library/stdtypes.rst:4582
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Restituisce una nuova vista delle chiavi del dizionario. Vedi la :ref:"
"`documentazione degli oggetti view <dict-views>`."

#: library/stdtypes.rst:4587
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Se *key* è nel dizionario, rimuovilo e restituisci il suo valore, altrimenti "
"restituisci *default*. Se *default* non è fornito e *key* non è nel "
"dizionario, viene sollevata una :exc:`KeyError`."

#: library/stdtypes.rst:4593
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Rimuove e restituisce una coppia ``(key, value)`` dal dizionario. Le coppie "
"sono restituite in ordine :abbr:`LIFO (last-in, first-out)`."

#: library/stdtypes.rst:4596
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` è utile per iterare distruttivamente su un dizionario, come "
"spesso utilizzato negli algoritmi di set. Se il dizionario è vuoto, "
"chiamare :meth:`popitem` solleva una :exc:`KeyError`."

#: library/stdtypes.rst:4600
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"L'ordine LIFO è ora garantito. Nelle versioni precedenti, :meth:`popitem` "
"avrebbe restituito una coppia chiave/valore arbitraria."

#: library/stdtypes.rst:4606
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Restituisce un iteratore inverso sulle chiavi del dizionario. Questo è un "
"collegamento rapido per ``reversed(d.keys())``."

#: library/stdtypes.rst:4613
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Se *key* è nel dizionario, restituisce il suo valore. Se non lo è, inserisce "
"*key* con un valore di *default* e restituisce *default*. *default* "
"predefinito è ``None``."

#: library/stdtypes.rst:4619
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Aggiorna il dizionario con le coppie chiave/valore da *other*, "
"sovrascrivendo le chiavi esistenti. Restituisce ``None``."

#: library/stdtypes.rst:4622
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` accetta un altro oggetto dizionario o un iterabile di coppie "
"chiave/valore (come tuple o altri iterabili di lunghezza due). Se vengono "
"specificati argomenti di parole chiave, il dizionario viene quindi "
"aggiornato con quelle coppie chiave/valore: ``d.update(red=1, blue=2)``."

#: library/stdtypes.rst:4629
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Restituisce una nuova vista dei valori del dizionario. Vedi la :ref:"
"`documentazione degli oggetti view <dict-views>`."

#: library/stdtypes.rst:4632
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"Un confronto di uguaglianza tra una vista ``dict.values()`` e un'altra "
"restituirà sempre ``False``. Questo vale anche quando si confronta ``dict."
"values()`` con se stesso::"

#: library/stdtypes.rst:4642
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"Crea un nuovo dizionario con le chiavi e i valori uniti di *d* e *other*, "
"che devono essere entrambi dizionari. I valori di *other* hanno la priorità "
"quando *d* e *other* condividono chiavi."

#: library/stdtypes.rst:4650
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"Aggiorna il dizionario *d* con chiavi e valori da *other*, che può essere "
"un :term:`mapping` o un :term:`iterable` di coppie chiave/valore. I valori "
"di *other* hanno la priorità quando *d* e *other* condividono chiavi."

#: library/stdtypes.rst:4656
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"I dizionari si confrontano uguali se e solo se hanno le stesse coppie "
"``(key, value)`` (indipendentemente dall'ordinamento). I confronti di ordine "
"('<', '<=', '>=', '>') sollevano :exc:`TypeError`."

#: library/stdtypes.rst:4660
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"I dizionari preservano l'ordine di inserimento. Nota che aggiornare una "
"chiave non influenza l'ordine. Le chiavi aggiunte dopo la cancellazione "
"vengono inserite alla fine. ::"

#: library/stdtypes.rst:4678
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"L'ordine del dizionario è garantito essere l'ordine di inserimento. Questo "
"comportamento era un dettaglio di implementazione di CPython dalla versione "
"3.6."

#: library/stdtypes.rst:4682
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "I dizionari e le viste del dizionario sono reversibili. ::"

#: library/stdtypes.rst:4694
msgid "Dictionaries are now reversible."
msgstr "I dizionari sono ora reversibili."

#: library/stdtypes.rst:4699
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` può essere utilizzato per creare una vista "
"di sola lettura di un :class:`dict`."

#: library/stdtypes.rst:4706
msgid "Dictionary view objects"
msgstr "Oggetti vista del dizionario"

#: library/stdtypes.rst:4708
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Gli oggetti restituiti da :meth:`dict.keys`, :meth:`dict.values` e :meth:"
"`dict.items` sono *oggetti vista*. Forniscono una vista dinamica sulle voci "
"del dizionario, il che significa che quando il dizionario cambia, la vista "
"riflette questi cambiamenti."

#: library/stdtypes.rst:4713
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Le viste del dizionario possono essere iterate per restituire i rispettivi "
"dati e supportano i test di appartenenza:"

#: library/stdtypes.rst:4718
msgid "Return the number of entries in the dictionary."
msgstr "Restituisce il numero di voci nel dizionario."

#: library/stdtypes.rst:4722
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Restituisce un iteratore sulle chiavi, valori o elementi (rappresentati come "
"tuple ``(key, value)``) nel dizionario."

#: library/stdtypes.rst:4725
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Le chiavi e i valori sono iterati in ordine di inserimento. Questo permette "
"la creazione di coppie ``(value, key)`` usando :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``. Un altro modo per creare la stessa lista è ``pairs = "
"[(v, k) for (k, v) in d.items()]``."

#: library/stdtypes.rst:4730
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Le viste di iterazione durante l'aggiunta o l'eliminazione di voci nel "
"dizionario possono sollevare una :exc:`RuntimeError` o fallire nell'iterare "
"su tutte le voci."

#: library/stdtypes.rst:4733
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "L'ordine del dizionario è garantito essere l'ordine di inserimento."

#: library/stdtypes.rst:4738
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Restituisce ``True`` se *x* è nelle chiavi, valori o elementi del dizionario "
"sottostante (in quest'ultimo caso, *x* deve essere una tupla ``(key, "
"value)``)."

#: library/stdtypes.rst:4743
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Restituisce un iteratore inverso sulle chiavi, valori o elementi del "
"dizionario. La vista verrà iterata in ordine inverso rispetto "
"all'inserimento."

#: library/stdtypes.rst:4746
msgid "Dictionary views are now reversible."
msgstr "Le viste del dizionario sono ora reversibili."

#: library/stdtypes.rst:4751
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"Restituisce un :class:`types.MappingProxyType` che incapsula il dizionario "
"originale cui si riferisce la vista."

#: library/stdtypes.rst:4756
msgid ""
"Keys views are set-like since their entries are unique and :term:`hashable`. "
"Items views also have set-like operations since the (key, value) pairs are "
"unique and the keys are hashable. If all values in an items view are "
"hashable as well, then the items view can interoperate with other sets. "
"(Values views are not treated as set-like since the entries are generally "
"not unique.)  For set-like views, all of the operations defined for the "
"abstract base class :class:`collections.abc.Set` are available (for example, "
"``==``, ``<``, or ``^``).  While using set operators, set-like views accept "
"any iterable as the other operand, unlike sets which only accept sets as the "
"input."
msgstr ""
"Le viste delle chiavi sono simili a insiemi poiché le loro voci sono uniche "
"e :term:`hashable`. Anche le viste degli elementi hanno operazioni simili a "
"insiemi poiché le coppie (key, value) sono uniche e le chiavi sono hashable. "
"Se anche tutti i valori in una vista di elementi sono hashable, allora la "
"vista degli elementi può interoperare con altri insiemi. (Le viste dei "
"valori non sono trattate come simili agli insiemi poiché le voci "
"generalmente non sono uniche.) Per le viste simili agli insiemi, sono "
"disponibili tutte le operazioni definite per la classe base astratta :class:"
"`collections.abc.Set` (ad esempio, ``==``, ``<``, o ``^``). Durante l'uso "
"degli operatori di insiemi, le viste simili agli insiemi accettano qualsiasi "
"iterabile come l'altro operando, a differenza degli insiemi che accettano "
"solo insiemi come input."

#: library/stdtypes.rst:4768
msgid "An example of dictionary view usage::"
msgstr "Un esempio di utilizzo delle viste del dizionario::"

#: library/stdtypes.rst:4812
msgid "Context Manager Types"
msgstr "Tipi di gestori di contesti"

#: library/stdtypes.rst:4819
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"La dichiarazione :keyword:`with` di Python supporta il concetto di un "
"contesto di runtime definito da un gestore di contesto. Questo è "
"implementato utilizzando una coppia di metodi che consentono alle classi "
"definite dall'utente di definire un contesto di runtime che viene inserito "
"prima che il corpo della dichiarazione venga eseguito ed esce quando la "
"dichiarazione termina:"

#: library/stdtypes.rst:4827
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Entra nel contesto di runtime e restituisce questo oggetto o un altro "
"oggetto relativo al contesto di runtime. Il valore restituito da questo "
"metodo è associato all'identificatore nella clausola :keyword:`!as` di "
"dichiarazioni :keyword:`with` che usano questo gestore di contesto."

#: library/stdtypes.rst:4832
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Un esempio di un gestore di contesto che restituisce se stesso è un :term:"
"`file object`. Gli oggetti file restituiscono se stessi da __enter__() per "
"permettere di usare :func:`open` come espressione di contesto in una "
"dichiarazione :keyword:`with`."

#: library/stdtypes.rst:4836
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Un esempio di un gestore di contesto che restituisce un oggetto correlato è "
"quello restituito da :func:`decimal.localcontext`. Questi gestori impostano "
"il contesto decimale attivo su una copia del contesto decimale originale e "
"quindi restituiscono la copia. Questo consente di apportare modifiche al "
"contesto decimale corrente nel corpo della dichiarazione :keyword:`with` "
"senza influenzare il codice al di fuori della dichiarazione :keyword:`!with`."

#: library/stdtypes.rst:4846
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Esce dal contesto di runtime e restituisce un flag booleano che indica se "
"deve essere soppressa un'eccezione che si è verificata. Se si è verificata "
"un'eccezione durante l'esecuzione del corpo della dichiarazione :keyword:"
"`with`, gli argomenti contengono il tipo di eccezione, il valore e le "
"informazioni di traceback. Altrimenti, tutti e tre gli argomenti sono "
"``None``."

#: library/stdtypes.rst:4851
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Restituire un valore vero da questo metodo farà sì che la dichiarazione :"
"keyword:`with` sopprima l'eccezione e continui l'esecuzione con l'istruzione "
"immediatamente successiva alla dichiarazione :keyword:`!with`. Altrimenti, "
"l'eccezione continua a propagarsi dopo che questo metodo ha terminato "
"l'esecuzione. Le eccezioni che si verificano durante l'esecuzione di questo "
"metodo sostituiranno qualsiasi eccezione che si è verificata nel corpo della "
"dichiarazione :keyword:`!with`."

#: library/stdtypes.rst:4858
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`~object."
"__exit__` method has actually failed."
msgstr ""
"L'eccezione passata non dovrebbe mai essere riesposta esplicitamente - "
"invece, questo metodo dovrebbe restituire un valore falso per indicare che "
"il metodo è stato completato con successo e non vuole sopprimere l'eccezione "
"sollevata. Questo consente al codice di gestione del contesto di rilevare "
"facilmente se un metodo :meth:`~object.__exit__` ha effettivamente fallito."

#: library/stdtypes.rst:4864
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python definisce diversi gestori di contesto per supportare una facile "
"sincronizzazione dei thread, la chiusura rapida di file o altri oggetti e "
"una manipolazione più semplice del contesto di aritmetica decimale attivo. I "
"tipi specifici non sono trattati in modo speciale oltre alla loro "
"implementazione del protocollo di gestione del contesto. Vedi il modulo :mod:"
"`contextlib` per alcuni esempi."

#: library/stdtypes.rst:4870
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"I :term:`generator`\\i di Python e il decoratore :class:`contextlib."
"contextmanager` forniscono un modo conveniente per implementare questi "
"protocolli. Se una funzione generatrice è decorata con il decoratore :class:"
"`contextlib.contextmanager`, restituirà un gestore di contesto che "
"implementa i metodi necessari :meth:`~contextmanager.__enter__` e :meth:"
"`~contextmanager.__exit__`, piuttosto che l'iteratore prodotto da una "
"funzione generatrice non decorata."

#: library/stdtypes.rst:4877
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Si noti che non esiste uno slot specifico per nessuno di questi metodi nella "
"struttura dei tipi per gli oggetti Python nell'API Python/C. I tipi di "
"estensione che desiderano definire questi metodi devono fornirli come un "
"normale metodo accessibile da Python. Rispetto al sovraccarico di impostare "
"il contesto di runtime, il sovraccarico di una singola ricerca nel "
"dizionario della classe è trascurabile."

#: library/stdtypes.rst:4885
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"Tipi di annotazione di tipo --- :ref:`Alias generico <types-genericalias>`, :"
"ref:`Union <types-union>`"

#: library/stdtypes.rst:4890
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
"I tipi core incorporati per :term:`type annotations <annotation>` sono :ref:"
"`Generic Alias <types-genericalias>` e :ref:`Union <types-union>`."

#: library/stdtypes.rst:4897
msgid "Generic Alias Type"
msgstr "Tipo Generic Alias"

#: library/stdtypes.rst:4903
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"Gli oggetti ``GenericAlias`` sono generalmente creati tramite :ref:"
"`subscripting <subscriptions>` di una classe. Sono più spesso utilizzati "
"con :ref:`container classes <sequence-types>`, come :class:`list` o :class:"
"`dict`. Ad esempio, ``list[int]`` è un oggetto ``GenericAlias`` creato "
"facendo subscripting della classe ``list`` con l'argomento :class:`int`. Gli "
"oggetti ``GenericAlias`` sono progettati principalmente per essere usati "
"con :term:`type annotations <annotation>`."

#: library/stdtypes.rst:4913
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"Generalmente è possibile fare subscripting di una classe solo se la classe "
"implementa il metodo speciale :meth:`~object.__class_getitem__`."

#: library/stdtypes.rst:4916
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"Un oggetto ``GenericAlias`` funge da proxy per un :term:`generic type`, "
"implementando *parameterized generics*."

#: library/stdtypes.rst:4919
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"Per una container class, l'argomento o gli argomenti forniti a un :ref:"
"`subscription <subscriptions>` della classe possono indicare il tipo o i "
"tipi degli elementi che un oggetto contiene. Ad esempio, ``set[bytes]`` può "
"essere utilizzato nelle type annotations per indicare un :class:`set` in cui "
"tutti gli elementi sono di tipo :class:`bytes`."

#: library/stdtypes.rst:4925
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"Per una classe che definisce :meth:`~object.__class_getitem__` ma non è un "
"container, l'argomento o gli argomenti forniti a un subscription della "
"classe spesso indicheranno il tipo di ritorno di uno o più metodi definiti "
"su un oggetto. Ad esempio, :mod:`regular expressions <re>` può essere "
"utilizzato sia sul tipo di dato :class:`str` che sul tipo di dato :class:"
"`bytes`:"

#: library/stdtypes.rst:4931
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"Se ``x = re.search('foo', 'foo')``, ``x`` sarà un oggetto :ref:`re.Match "
"<match-objects>` dove i valori di ritorno di ``x.group(0)`` e ``x[0]`` "
"saranno entrambi di tipo :class:`str`. Possiamo rappresentare questo tipo di "
"oggetto nelle type annotations con il ``GenericAlias`` ``re.Match[str]``."

#: library/stdtypes.rst:4937
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"Se ``y = re.search(b'bar', b'bar')``, (nota il ``b`` per :class:`bytes`), "
"``y`` sarà anch'esso un'istanza di ``re.Match``, ma i valori di ritorno di "
"``y.group(0)`` e ``y[0]`` saranno entrambi di tipo :class:`bytes`. Nelle "
"type annotations, rappresenteremmo questa varietà di oggetti :ref:`re.Match "
"<match-objects>` con ``re.Match[bytes]``."

#: library/stdtypes.rst:4943
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"Gli oggetti ``GenericAlias`` sono istanze della classe :class:`types."
"GenericAlias`, che può essere utilizzata anche per creare direttamente "
"oggetti ``GenericAlias``."

#: library/stdtypes.rst:4949
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Crea un ``GenericAlias`` che rappresenta un tipo ``T`` parametrizzato dai "
"tipi *X*, *Y* e altro a seconda del ``T`` utilizzato. Ad esempio, una "
"funzione che si aspetta una :class:`list` contenente elementi di tipo :class:"
"`float`::"

#: library/stdtypes.rst:4957
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Un altro esempio per gli oggetti :term:`mapping`, utilizzando un :class:"
"`dict`, che è un tipo generico che si aspetta due parametri di tipo che "
"rappresentano il tipo delle chiavi e il tipo dei valori. In questo esempio, "
"la funzione si aspetta un ``dict`` con chiavi di tipo :class:`str` e valori "
"di tipo :class:`int`::"

#: library/stdtypes.rst:4965
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"Le funzioni incorporate :func:`isinstance` e :func:`issubclass` non "
"accettano tipi ``GenericAlias`` come secondo argomento::"

#: library/stdtypes.rst:4973
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Il runtime Python non impone :term:`type annotations <annotation>`. Questo "
"si estende ai tipi generici e ai loro parametri di tipo. Quando si crea un "
"oggetto container da un ``GenericAlias``, gli elementi nel container non "
"vengono verificati in base al loro tipo. Ad esempio, il seguente codice è "
"sconsigliato, ma verrà eseguito senza errori::"

#: library/stdtypes.rst:4983
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Inoltre, i generici parametrizzati eliminano i parametri di tipo durante la "
"creazione dell'oggetto::"

#: library/stdtypes.rst:4994
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Chiamare :func:`repr` o :func:`str` su un generico mostra il tipo "
"parametrizzato::"

#: library/stdtypes.rst:5002
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"Il metodo :meth:`~object.__getitem__` dei container generici solleverà "
"un'eccezione per impedire errori come ``dict[str][str]``::"

#: library/stdtypes.rst:5010
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Tuttavia, tali espressioni sono valide quando vengono utilizzate le :ref:"
"`type variables <generics>`. L'indice deve avere tanti elementi quanti sono "
"gli item delle variabili di tipo nell'oggetto ``GenericAlias`` :attr:"
"`~genericalias.__args__`.::"

#: library/stdtypes.rst:5021
msgid "Standard Generic Classes"
msgstr "Classi Generiche Standard"

#: library/stdtypes.rst:5023
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"Le seguenti classi della libreria standard supportano i generici "
"parametrizzati. Questa lista non è esaustiva."

#: library/stdtypes.rst:5026
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:5027
msgid ":class:`list`"
msgstr ":class:`list`"

#: library/stdtypes.rst:5028
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: library/stdtypes.rst:5029
msgid ":class:`set`"
msgstr ":class:`set`"

#: library/stdtypes.rst:5030
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: library/stdtypes.rst:5031
msgid ":class:`type`"
msgstr ":class:`type`"

#: library/stdtypes.rst:5032
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: library/stdtypes.rst:5033
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: library/stdtypes.rst:5034
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: library/stdtypes.rst:5035
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: library/stdtypes.rst:5036
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: library/stdtypes.rst:5037
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: library/stdtypes.rst:5038
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: library/stdtypes.rst:5039
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: library/stdtypes.rst:5040
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: library/stdtypes.rst:5041
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: library/stdtypes.rst:5042
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: library/stdtypes.rst:5043
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: library/stdtypes.rst:5044
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: library/stdtypes.rst:5045
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: library/stdtypes.rst:5046
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: library/stdtypes.rst:5047
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: library/stdtypes.rst:5048
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: library/stdtypes.rst:5049
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: library/stdtypes.rst:5050
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: library/stdtypes.rst:5051
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: library/stdtypes.rst:5052
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: library/stdtypes.rst:5053
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: library/stdtypes.rst:5054
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: library/stdtypes.rst:5055
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: library/stdtypes.rst:5056
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: library/stdtypes.rst:5057
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: library/stdtypes.rst:5058
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: library/stdtypes.rst:5059
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: library/stdtypes.rst:5060
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: library/stdtypes.rst:5061
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: library/stdtypes.rst:5062
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: library/stdtypes.rst:5063
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: library/stdtypes.rst:5064
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: library/stdtypes.rst:5065
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: library/stdtypes.rst:5066
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: library/stdtypes.rst:5067
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: library/stdtypes.rst:5068
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: library/stdtypes.rst:5069
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: library/stdtypes.rst:5070
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: library/stdtypes.rst:5071
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: library/stdtypes.rst:5072
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: library/stdtypes.rst:5073
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: library/stdtypes.rst:5074
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: library/stdtypes.rst:5075
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: library/stdtypes.rst:5076
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: library/stdtypes.rst:5077
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: library/stdtypes.rst:5078
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: library/stdtypes.rst:5079
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: library/stdtypes.rst:5084
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Attributi Speciali per oggetti ``GenericAlias``"

#: library/stdtypes.rst:5086
msgid "All parameterized generics implement special read-only attributes."
msgstr ""
"Tutti i generici parametrici implementano attributi speciali di sola lettura."

#: library/stdtypes.rst:5090
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Questo attributo punta alla classe generica non parametrizzata::"

#: library/stdtypes.rst:5098
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Questo attributo è una :class:`tuple` (possibilmente di lunghezza 1) di tipi "
"generici passati al metodo originale :meth:`~object.__class_getitem__` della "
"classe generica::"

#: library/stdtypes.rst:5108
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Questo attributo è una tupla calcolata pigramente (possibilmente vuota) di "
"variabili di tipo uniche trovate in ``__args__``::"

#: library/stdtypes.rst:5119
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"Un oggetto ``GenericAlias`` con parametri :class:`typing.ParamSpec` potrebbe "
"non avere ``__parameters__`` corretti dopo la sostituzione perché :class:"
"`typing.ParamSpec` è destinato principalmente al controllo statico dei tipi."

#: library/stdtypes.rst:5126
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr ""
"Un booleano che è vero se l'alias è stato espanso usando l'operatore ``*`` "
"(vedere :data:`~typing.TypeVarTuple`)."

#: library/stdtypes.rst:5134
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Suggerimenti di Tipo"

#: library/stdtypes.rst:5135
msgid "Introducing Python's framework for type annotations."
msgstr "Introduzione al framework di Python per le annotazioni di tipo."

#: library/stdtypes.rst:5137
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Indicazione di Tipo Generica nelle Collezioni Standard"

#: library/stdtypes.rst:5138
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"Introduzione alla capacità di parametrizzare nativamente le classi della "
"libreria standard, a condizione che implementino il metodo speciale di "
"classe :meth:`~object.__class_getitem__`."

#: library/stdtypes.rst:5142
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` e :"
"class:`typing.Generic`"

#: library/stdtypes.rst:5143
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Documentazione su come implementare classi generiche che possono essere "
"parametrizzate in fase di esecuzione e comprese dai controllori di tipo "
"statico."

#: library/stdtypes.rst:5152
msgid "Union Type"
msgstr "Tipo Unione"

#: library/stdtypes.rst:5158
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""
"Un oggetto unione contiene il valore dell'operazione ``|`` (or bit a bit) su "
"più :ref:`oggetti di tipo <bltin-type-objects>`. Questi tipi sono destinati "
"principalmente alle :term:`annotazioni di tipo <annotation>`. L'espressione "
"del tipo unione consente una sintassi più pulita per i suggerimenti di tipo "
"rispetto a :data:`typing.Union`."

#: library/stdtypes.rst:5165
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"Definisce un oggetto unione che contiene i tipi *X*, *Y*, e così via. ``X | "
"Y`` significa X o Y. È equivalente a ``typing.Union[X, Y]``. Ad esempio, la "
"seguente funzione si aspetta un argomento di tipo :class:`int` o :class:"
"`float`::"

#: library/stdtypes.rst:5175
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. "
"For unions which include forward references, present the whole expression as "
"a string, e.g. ``\"int | Foo\"``."
msgstr ""
"L'operando ``|`` non può essere utilizzato in fase di esecuzione per "
"definire unioni dove uno o più membri sono un riferimento in avanti. Ad "
"esempio, ``int | \"Foo\"``, dove ``\"Foo\"`` è un riferimento a una classe "
"non ancora definita, fallirà in fase di esecuzione. Per le unioni che "
"includono riferimenti in avanti, presentare l'intera espressione come una "
"stringa, ad esempio ``\"int | Foo\"``."

#: library/stdtypes.rst:5183
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Gli oggetti unione possono essere testati per uguaglianza con altri oggetti "
"unione. Dettagli:"

#: library/stdtypes.rst:5185
msgid "Unions of unions are flattened::"
msgstr "Le unioni di unioni sono appiattite::"

#: library/stdtypes.rst:5189
msgid "Redundant types are removed::"
msgstr "I tipi ridondanti sono rimossi::"

#: library/stdtypes.rst:5193
msgid "When comparing unions, the order is ignored::"
msgstr "Quando si confrontano le unioni, l'ordine è ignorato::"

#: library/stdtypes.rst:5197
msgid "It is compatible with :data:`typing.Union`::"
msgstr "È compatibile con :data:`typing.Union`::"

#: library/stdtypes.rst:5201
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "I tipi opzionali possono essere scritti come un'unione con ``None``::"

#: library/stdtypes.rst:5208
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
"Anche le chiamate a :func:`isinstance` e :func:`issubclass` sono supportate "
"con un oggetto unione::"

#: library/stdtypes.rst:5214
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""
"Tuttavia, :ref:`generici parametrici <types-genericalias>` negli oggetti "
"unione non possono essere verificati::"

#: library/stdtypes.rst:5224
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"Il tipo esposto all'utente per l'oggetto unione può essere accessibile da :"
"data:`types.UnionType` e utilizzato per i controlli :func:`isinstance`. Un "
"oggetto non può essere istanziato dal tipo::"

#: library/stdtypes.rst:5237
msgid ""
"The :meth:`!__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`!__or__`, the Union may "
"override it:"
msgstr ""
"Il metodo :meth:`!__or__` per gli oggetti di tipo è stato aggiunto per "
"supportare la sintassi ``X | Y``. Se una metaclasse implementa :meth:`!"
"__or__`, l'Unione può sovrascriverlo:"

#: library/stdtypes.rst:5257
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- PEP che propone la sintassi ``X | Y`` e il tipo Unione."

#: library/stdtypes.rst:5265
msgid "Other Built-in Types"
msgstr "Altri Tipi Integrati"

#: library/stdtypes.rst:5267
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"L'interprete supporta diversi altri tipi di oggetti. La maggior parte di "
"questi supporta solo una o due operazioni."

#: library/stdtypes.rst:5274
msgid "Modules"
msgstr "Moduli"

#: library/stdtypes.rst:5276
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"L'unica operazione speciale su un modulo è l'accesso agli attributi: ``m."
"name``, dove *m* è un modulo e *name* accede a un nome definito nella "
"tabella dei simboli di *m*. Gli attributi del modulo possono essere "
"assegnati. (Nota che l'istruzione :keyword:`import` non è, strettamente "
"parlando, un'operazione su un oggetto modulo; ``import foo`` non richiede "
"che esista un oggetto modulo chiamato *foo*, ma richiede una *definizione* "
"(esterna) per un modulo denominato *foo* da qualche parte.)"

#: library/stdtypes.rst:5283
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Un attributo speciale di ogni modulo è :attr:`~object.__dict__`. Questo è il "
"dizionario contenente la tabella dei simboli del modulo. La modifica di "
"questo dizionario cambierà effettivamente la tabella dei simboli del modulo, "
"ma l'assegnazione diretta all'attributo :attr:`~object.__dict__` non è "
"possibile (puoi scrivere ``m.__dict__['a'] = 1``, che definisce ``m.a`` come "
"``1``, ma non puoi scrivere ``m.__dict__ = {}``). Modificare direttamente :"
"attr:`~object.__dict__` non è consigliato."

#: library/stdtypes.rst:5291
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"I moduli integrati nell'interprete sono scritti così: ``<module 'sys' (built-"
"in)>``. Se caricati da un file, sono scritti come ``<module 'os' from '/usr/"
"local/lib/pythonX.Y/os.pyc'>``."

#: library/stdtypes.rst:5299
msgid "Classes and Class Instances"
msgstr "Classi e Istanze di Classe"

#: library/stdtypes.rst:5301
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Vedi :ref:`objects` e :ref:`class` per questi."

#: library/stdtypes.rst:5307
msgid "Functions"
msgstr "Funzioni"

#: library/stdtypes.rst:5309
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Gli oggetti funzione sono creati dalle definizioni di funzione. L'unica "
"operazione su un oggetto funzione è chiamarlo: ``func(lista-argomenti)``."

#: library/stdtypes.rst:5312
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Esistono realmente due tipi di oggetti funzione: funzioni integrate e "
"funzioni definite dall'utente. Entrambi supportano la stessa operazione "
"(chiamare la funzione), ma l'implementazione è diversa, da cui i diversi "
"tipi di oggetti."

#: library/stdtypes.rst:5316
msgid "See :ref:`function` for more information."
msgstr "Vedi :ref:`function` per ulteriori informazioni."

#: library/stdtypes.rst:5322
msgid "Methods"
msgstr "Metodi"

#: library/stdtypes.rst:5326
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: :ref:`built-in methods <builtin-methods>` (such as :meth:"
"`append` on lists) and :ref:`class instance method <instance-methods>`. "
"Built-in methods are described with the types that support them."
msgstr ""
"I metodi sono funzioni chiamate utilizzando la notazione degli attributi. Ci "
"sono due tipi: :ref:`metodi integrati <builtin-methods>` (come :meth:"
"`append` su liste) e :ref:`metodi delle istanze di classe <instance-"
"methods>`. I metodi integrati sono descritti con i tipi che li supportano."

#: library/stdtypes.rst:5331
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :ref:"
"`instance method <instance-methods>`) object. When called, it will add the "
"``self`` argument to the argument list.  Bound methods have two special read-"
"only attributes: :attr:`m.__self__ <method.__self__>` is the object on which "
"the method operates, and :attr:`m.__func__ <method.__func__>` is the "
"function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` "
"is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Se accedi a un metodo (una funzione definita in uno spazio dei nomi di una "
"classe) tramite un'istanza, ottieni un oggetto speciale: un oggetto :dfn:"
"`metodo vincolato` (anche chiamato :ref:`metodo istanza <instance-"
"methods>`). Quando viene chiamato, aggiungerà l'argomento ``self`` "
"all'elenco degli argomenti. I metodi vincolati hanno due attributi speciali "
"di sola lettura: :attr:`m.__self__ <method.__self__>` è l'oggetto su cui il "
"metodo opera, e :attr:`m.__func__ <method.__func__>` è la funzione che "
"implementa il metodo. Chiamare ``m(arg-1, arg-2, ..., arg-n)`` è "
"completamente equivalente a chiamare ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."

#: library/stdtypes.rst:5342
msgid ""
"Like :ref:`function objects <user-defined-funcs>`, bound method objects "
"support getting arbitrary attributes.  However, since method attributes are "
"actually stored on the underlying function object (:attr:`method.__func__`), "
"setting method attributes on bound methods is disallowed.  Attempting to set "
"an attribute on a method results in an :exc:`AttributeError` being raised.  "
"In order to set a method attribute, you need to explicitly set it on the "
"underlying function object:"
msgstr ""
"Come :ref:`oggetti funzione <user-defined-funcs>`, gli oggetti metodo "
"vincolati supportano l'acquisizione di attributi arbitrari. Tuttavia, poiché "
"gli attributi del metodo sono effettivamente memorizzati sull'oggetto "
"funzione sottostante (:attr:`method.__func__`), impostare attributi del "
"metodo sui metodi vincolati non è consentito. Il tentativo di impostare un "
"attributo su un metodo provoca il sollevamento di un'eccezione :exc:"
"`AttributeError`. Per impostare un attributo del metodo, devi esplicitamente "
"impostarlo sull'oggetto funzione sottostante:"

#: library/stdtypes.rst:5365
msgid "See :ref:`instance-methods` for more information."
msgstr "Vedi :ref:`instance-methods` per ulteriori informazioni."

#: library/stdtypes.rst:5373
msgid "Code Objects"
msgstr "Oggetti Codice"

#: library/stdtypes.rst:5379
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`~function.__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Gli oggetti codice sono utilizzati dall'implementazione per rappresentare il "
"codice Python \"pseudo-compilato\" eseguibile come il corpo di una funzione. "
"Differiscono dagli oggetti funzione perché non contengono un riferimento al "
"loro ambiente di esecuzione globale. Gli oggetti codice sono restituiti "
"dalla funzione integrata :func:`compile` e possono essere estratti dagli "
"oggetti funzione attraverso il loro attributo :attr:`~function.__code__`. "
"Vedi anche il modulo :mod:`code`."

#: library/stdtypes.rst:5386
msgid ""
"Accessing :attr:`~function.__code__` raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and "
"``\"__code__\"``."
msgstr ""
"L'accesso a :attr:`~function.__code__` solleva un :ref:`evento di auditing "
"<auditing>` ``object.__getattr__`` con argomenti ``obj`` e ``\"__code__\"``."

#: library/stdtypes.rst:5393
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Un oggetto codice può essere eseguito o valutato passandolo (anziché una "
"stringa sorgente) alle funzioni integrate :func:`exec` o :func:`eval`."

#: library/stdtypes.rst:5396
msgid "See :ref:`types` for more information."
msgstr "Vedi :ref:`types` per ulteriori informazioni."

#: library/stdtypes.rst:5402
msgid "Type Objects"
msgstr "Oggetti Tipo"

#: library/stdtypes.rst:5408
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Gli oggetti tipo rappresentano i vari tipi di oggetto. Il tipo di un oggetto "
"è accessibile tramite la funzione integrata :func:`type`. Non ci sono "
"operazioni speciali sui tipi. Il modulo standard :mod:`types` definisce nomi "
"per tutti i tipi integrati standard."

#: library/stdtypes.rst:5413
msgid "Types are written like this: ``<class 'int'>``."
msgstr "I tipi sono scritti così: ``<class 'int'>``."

#: library/stdtypes.rst:5419
msgid "The Null Object"
msgstr "L'Oggetto Null"

#: library/stdtypes.rst:5421
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Questo oggetto è restituito da funzioni che non restituiscono esplicitamente "
"un valore. Non supporta operazioni speciali. C'è esattamente un oggetto "
"null, chiamato ``None`` (un nome integrato). ``type(None)()`` produce lo "
"stesso singleton."

#: library/stdtypes.rst:5425
msgid "It is written as ``None``."
msgstr "È scritto come ``None``."

#: library/stdtypes.rst:5432
msgid "The Ellipsis Object"
msgstr "L'Oggetto Ellipsis"

#: library/stdtypes.rst:5434
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Questo oggetto è comunemente usato dall'operatore di slicing (vedi :ref:"
"`slicings`). Non supporta operazioni speciali. C'è esattamente un oggetto "
"ellissi, chiamato :const:`Ellipsis` (un nome integrato). ``type(Ellipsis)"
"()`` produce il singleton :const:`Ellipsis`."

#: library/stdtypes.rst:5439
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "È scritto come ``Ellipsis`` o ``...``."

#: library/stdtypes.rst:5445
msgid "The NotImplemented Object"
msgstr "L'Oggetto NotImplemented"

#: library/stdtypes.rst:5447
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one :data:`NotImplemented` object. :code:"
"`type(NotImplemented)()` produces the singleton instance."
msgstr ""
"Questo oggetto è restituito da confronti e operazioni binarie quando questi "
"sono richiesti di operare su tipi che non supportano. Vedi :ref:"
"`comparisons` per maggiori informazioni. C'è esattamente un oggetto :data:"
"`NotImplemented`. :code:`type(NotImplemented)()` produce l'istanza singleton."

#: library/stdtypes.rst:5452
msgid "It is written as :code:`NotImplemented`."
msgstr "È scritto come :code:`NotImplemented`."

#: library/stdtypes.rst:5458
msgid "Internal Objects"
msgstr "Oggetti Interni"

#: library/stdtypes.rst:5460
msgid ""
"See :ref:`types` for this information.  It describes :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, and "
"slice objects."
msgstr ""
"Vedi :ref:`types` per queste informazioni. Descrive :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, e "
"oggetti slice."

#: library/stdtypes.rst:5468
msgid "Special Attributes"
msgstr "Attributi Speciali"

#: library/stdtypes.rst:5470
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"L'implementazione aggiunge alcuni attributi speciali di sola lettura a "
"diversi tipi di oggetti, ove rilevanti. Alcuni di questi non sono riportati "
"dalla funzione integrata :func:`dir`."

#: library/stdtypes.rst:5477
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Un dizionario o altro oggetto di mappatura usato per memorizzare gli "
"attributi (scrivibili) di un oggetto."

#: library/stdtypes.rst:5483
msgid "The class to which a class instance belongs."
msgstr "La classe a cui appartiene un'istanza di classe."

#: library/stdtypes.rst:5488
msgid "The tuple of base classes of a class object."
msgstr "La tupla delle classi base di un oggetto classe."

#: library/stdtypes.rst:5493
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""
"Il nome della classe, funzione, metodo, descrittore o istanza del generatore."

#: library/stdtypes.rst:5499
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Il :term:`qualified name` della classe, funzione, metodo, descrittore o "
"istanza del generatore."

#: library/stdtypes.rst:5507
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and :"
"ref:`type aliases <type-aliases>`."
msgstr ""
"I :ref:`parametri di tipo <type-params>` delle classi generiche, funzioni e :"
"ref:`alias di tipo <type-aliases>`."

#: library/stdtypes.rst:5515
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Questo attributo è una tupla di classi che sono considerate quando si "
"cercano classi base durante la risoluzione dei metodi."

#: library/stdtypes.rst:5521
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Questo metodo può essere sovrascritto da una metaclasse per personalizzare "
"l'ordine di risoluzione dei metodi per le sue istanze. È chiamato durante "
"l'istanza della classe, e il suo risultato è memorizzato in :attr:`~class."
"__mro__`."

#: library/stdtypes.rst:5528
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr ""
"Ogni classe mantiene un elenco di riferimenti deboli alle sue sottoclassi "
"immediate. Questo metodo restituisce un elenco di tutti quei riferimenti "
"ancora vivi. L'elenco è in ordine di definizione. Esempio::"

#: library/stdtypes.rst:5539
msgid "Integer string conversion length limitation"
msgstr "Limitazione della lunghezza di conversione delle stringhe di interi"

#: library/stdtypes.rst:5541
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""
"CPython ha un limite globale per la conversione tra :class:`int` e :class:"
"`str` per mitigare gli attacchi denial of service. Questo limite *si applica "
"solo* alle basi decimali o ad altre basi numeriche non potenze di due. Le "
"conversioni esadecimali, ottali e binarie sono illimitate. Il limite può "
"essere configurato."

#: library/stdtypes.rst:5546
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
"Il tipo :class:`int` in CPython è un numero di lunghezza arbitraria "
"memorizzato in forma binaria (comunemente noto come \"bignum\"). Non esiste "
"alcun algoritmo che possa convertire una stringa in un intero binario o un "
"intero binario in una stringa in tempo lineare, *a meno che* la base non sia "
"una potenza di 2. Anche i migliori algoritmi conosciuti per la base 10 hanno "
"una complessità sub-quadratica. La conversione di un valore grande come "
"``int('1' * 500_000)`` può richiedere più di un secondo su una CPU veloce."

#: library/stdtypes.rst:5553
msgid ""
"Limiting conversion size offers a practical way to avoid :cve:`2020-10735`."
msgstr ""
"Limitare la dimensione della conversione offre un modo pratico per evitare :"
"cve:`2020-10735`."

#: library/stdtypes.rst:5555
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""
"Il limite si applica al numero di caratteri numerici nella stringa di input "
"o output quando sarebbe coinvolto un algoritmo di conversione non lineare. "
"Gli underscore e il segno non vengono contati ai fini del limite."

#: library/stdtypes.rst:5559
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""
"Quando un'operazione supererebbe il limite, viene sollevata un'eccezione :"
"exc:`ValueError`:"

#: library/stdtypes.rst:5581
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""
"Il limite predefinito è di 4300 cifre come indicato in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. Il limite più basso che può essere "
"configurato è 640 cifre come indicato in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."

#: library/stdtypes.rst:5586
msgid "Verification:"
msgstr "Verifica:"

#: library/stdtypes.rst:5601
msgid "Affected APIs"
msgstr "API influenzate"

#: library/stdtypes.rst:5603
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""
"La limitazione si applica solo alle conversioni potenzialmente lente tra :"
"class:`int` e :class:`str` o :class:`bytes`:"

#: library/stdtypes.rst:5606
msgid "``int(string)`` with default base 10."
msgstr "``int(string)`` con base predefinita 10."

#: library/stdtypes.rst:5607
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "``int(string, base)`` per tutte le basi che non sono una potenza di 2."

#: library/stdtypes.rst:5608
msgid "``str(integer)``."
msgstr "``str(integer)``."

#: library/stdtypes.rst:5609
msgid "``repr(integer)``."
msgstr "``repr(integer)``."

#: library/stdtypes.rst:5610
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"qualsiasi altra conversione di stringhe in base 10, ad esempio "
"``f\"{integer}\"``, ``\"{}\".format(integer)``, o ``b\"%d\" % integer``."

#: library/stdtypes.rst:5613
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr ""
"Le limitazioni non si applicano alle funzioni con un algoritmo lineare:"

#: library/stdtypes.rst:5615
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(string, base)`` con base 2, 4, 8, 16 o 32."

#: library/stdtypes.rst:5616
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` e :func:`int.to_bytes`."

#: library/stdtypes.rst:5617
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: library/stdtypes.rst:5618
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ":ref:`formatspec` per i numeri esadecimali, ottali e binari."

#: library/stdtypes.rst:5619
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` a :class:`float`."

#: library/stdtypes.rst:5620
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` a :class:`decimal.Decimal`."

#: library/stdtypes.rst:5623
msgid "Configuring the limit"
msgstr "Configurazione del limite"

#: library/stdtypes.rst:5625
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""
"Prima dell'avvio di Python, è possibile utilizzare una variabile d'ambiente "
"o un flag da linea di comando dell'interprete per configurare il limite:"

#: library/stdtypes.rst:5628
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`, ad es. ``PYTHONINTMAXSTRDIGITS=640 "
"python3`` per impostare il limite a 640 o ``PYTHONINTMAXSTRDIGITS=0 "
"python3`` per disabilitare la limitazione."

#: library/stdtypes.rst:5631
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits <-X>`, ad es. ``python3 -X "
"int_max_str_digits=640``"

#: library/stdtypes.rst:5633
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits` contiene il valore di :envvar:"
"`PYTHONINTMAXSTRDIGITS` o :option:`-X int_max_str_digits <-X>`. Se sia la "
"variabile d'ambiente che l'opzione ``-X`` sono impostate, l'opzione ``-X`` "
"ha la precedenza. Un valore di *-1* indica che entrambi non erano impostati, "
"quindi durante l'inizializzazione è stato utilizzato un valore di :data:`sys."
"int_info.default_max_str_digits`."

#: library/stdtypes.rst:5639
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""
"Dal codice, puoi ispezionare il limite corrente e impostarne uno nuovo "
"utilizzando queste API del modulo :mod:`sys`:"

#: library/stdtypes.rst:5642
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""
":func:`sys.get_int_max_str_digits` e :func:`sys.set_int_max_str_digits` sono "
"un getter e un setter per il limite a livello dell'interprete. I sotto-"
"interpreti hanno il proprio limite."

#: library/stdtypes.rst:5646
msgid ""
"Information about the default and minimum can be found in :data:`sys."
"int_info`:"
msgstr ""
"Informazioni sul predefinito e sul minimo possono essere trovate in :data:"
"`sys.int_info`:"

#: library/stdtypes.rst:5648
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` è il limite "
"predefinito compilato."

#: library/stdtypes.rst:5650
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` è il valore "
"minimo accettato per il limite (ad eccezione di 0 che lo disabilita)."

#: library/stdtypes.rst:5657
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"Impostare un limite basso *può* portare a problemi. Sebbene raro, esiste del "
"codice che contiene costanti intere in decimale nel loro sorgente che "
"superano la soglia minima. Una conseguenza dell'impostazione del limite è "
"che il codice sorgente Python contenente letterali interi decimali più "
"lunghi del limite incontrerà un errore durante l'analisi, solitamente "
"all'avvio o al momento dell'importazione o anche durante l'installazione - "
"ogni volta che un ``.pyc`` non aggiornato non esiste già per il codice. Un "
"workaround per il sorgente che contiene tali costanti grandi è convertirle "
"in forma esadecimale ``0x`` poiché non ha limite."

#: library/stdtypes.rst:5666
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"Testa accuratamente la tua applicazione se utilizzi un limite basso. "
"Assicurati che i tuoi test vengano eseguiti con il limite impostato in "
"anticipo tramite l'ambiente o il flag in modo che si applichi durante "
"l'avvio e anche durante qualsiasi passaggio di installazione che potrebbe "
"invocare Python per precompilare i sorgenti ``.py`` in file ``.pyc``."

#: library/stdtypes.rst:5672
msgid "Recommended configuration"
msgstr "Configurazione consigliata"

#: library/stdtypes.rst:5674
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.12."
msgstr ""
"Il :data:`sys.int_info.default_max_str_digits` predefinito è previsto per "
"essere ragionevole per la maggior parte delle applicazioni. Se la tua "
"applicazione richiede un limite diverso, impostalo dal tuo punto di ingresso "
"principale utilizzando codice agnostico alla versione di Python poiché "
"queste API sono state aggiunte in rilasci di patch di sicurezza in versioni "
"precedenti alla 3.12."

#: library/stdtypes.rst:5679
msgid "Example::"
msgstr "Esempio::"

#: library/stdtypes.rst:5691
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "Se hai bisogno di disabilitarlo completamente, impostalo a ``0``."

#: library/stdtypes.rst:5695
msgid "Footnotes"
msgstr "Note a piè di pagina"

#: library/stdtypes.rst:5696
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Ulteriori informazioni su questi metodi speciali possono essere trovate nel "
"Manuale di Riferimento Python (:ref:`customization`)."

#: library/stdtypes.rst:5699
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Di conseguenza, l'elenco ``[1, 2]`` è considerato uguale a ``[1.0, 2.0]``, e "
"analogamente per le tuple."

#: library/stdtypes.rst:5702
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Devono esserlo poiché il parser non può determinare il tipo degli operandi."

#: library/stdtypes.rst:5704
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"I caratteri con distinzione di maiuscole e minuscole sono quelli con "
"proprietà di categoria generale \"Lu\" (Lettera, maiuscola), "
"\"Ll\" (Lettera, minuscola) o \"Lt\" (Lettera, maiuscola a inizio parola)."

#: library/stdtypes.rst:5707
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Per formattare solo una tupla, dovresti quindi fornire una tupla singleton "
"il cui unico elemento è la tupla da formattare."

#: library/stdtypes.rst:13
msgid "built-in"
msgstr "incorporato"

#: library/stdtypes.rst:316 library/stdtypes.rst:950 library/stdtypes.rst:1139
#: library/stdtypes.rst:4421 library/stdtypes.rst:5404
msgid "types"
msgstr "tipi"

#: library/stdtypes.rst:1154 library/stdtypes.rst:4421
msgid "statement"
msgstr "istruzione"

#: library/stdtypes.rst:34
msgid "if"
msgstr "if"

#: library/stdtypes.rst:34
msgid "while"
msgstr "while"

#: library/stdtypes.rst:34
msgid "truth"
msgstr "verità"

#: library/stdtypes.rst:34
msgid "value"
msgstr "valore"

#: library/stdtypes.rst:81 library/stdtypes.rst:817
msgid "Boolean"
msgstr "Booleano"

#: library/stdtypes.rst:81 library/stdtypes.rst:393
msgid "operations"
msgstr "operazioni"

#: library/stdtypes.rst:34
msgid "false"
msgstr "falso"

#: library/stdtypes.rst:44
msgid "true"
msgstr "vero"

#: library/stdtypes.rst:52
msgid "None (Built-in object)"
msgstr "None (Oggetto integrato)"

#: library/stdtypes.rst:52
msgid "False (Built-in object)"
msgstr "False (Oggetto integrato)"

#: library/stdtypes.rst:98 library/stdtypes.rst:195 library/stdtypes.rst:393
#: library/stdtypes.rst:950
msgid "operator"
msgstr "operatore"

#: library/stdtypes.rst:98
msgid "or"
msgstr "oppure"

#: library/stdtypes.rst:98
msgid "and"
msgstr "e"

#: library/stdtypes.rst:817
msgid "False"
msgstr "Falso"

#: library/stdtypes.rst:817
msgid "True"
msgstr "Vero"

#: library/stdtypes.rst:98
msgid "not"
msgstr "non"

#: library/stdtypes.rst:123
msgid "chaining"
msgstr "concatenamento"

#: library/stdtypes.rst:123
msgid "comparisons"
msgstr "confronti"

#: library/stdtypes.rst:123
msgid "comparison"
msgstr "confronto"

#: library/stdtypes.rst:123
msgid "=="
msgstr "=="

#: library/stdtypes.rst:123
msgid "< (less)"
msgstr "< (minore)"

#: library/stdtypes.rst:123
msgid "<="
msgstr "<="

#: library/stdtypes.rst:123
msgid "> (greater)"
msgstr "> (maggiore)"

#: library/stdtypes.rst:123
msgid ">="
msgstr ">="

#: library/stdtypes.rst:123
msgid "!="
msgstr "!="

#: library/stdtypes.rst:123
msgid "is"
msgstr "è"

#: library/stdtypes.rst:123
msgid "is not"
msgstr "non è"

#: library/stdtypes.rst:208 library/stdtypes.rst:1117 library/stdtypes.rst:1259
#: library/stdtypes.rst:1382 library/stdtypes.rst:1539
#: library/stdtypes.rst:2532 library/stdtypes.rst:4219
#: library/stdtypes.rst:4899 library/stdtypes.rst:5324
#: library/stdtypes.rst:5368
msgid "object"
msgstr "oggetto"

#: library/stdtypes.rst:208 library/stdtypes.rst:316 library/stdtypes.rst:335
msgid "numeric"
msgstr "numerico"

#: library/stdtypes.rst:163
msgid "objects"
msgstr "oggetti"

#: library/stdtypes.rst:163
msgid "comparing"
msgstr "confrontare"

#: library/stdtypes.rst:173
msgid "__eq__() (instance method)"
msgstr "__eq__() (metodo di istanza)"

#: library/stdtypes.rst:173
msgid "__ne__() (instance method)"
msgstr "__ne__() (metodo di istanza)"

#: library/stdtypes.rst:173
msgid "__lt__() (instance method)"
msgstr "__lt__() (metodo di istanza)"

#: library/stdtypes.rst:173
msgid "__le__() (instance method)"
msgstr "__le__() (metodo di istanza)"

#: library/stdtypes.rst:173
msgid "__gt__() (instance method)"
msgstr "__gt__() (metodo di istanza)"

#: library/stdtypes.rst:173
msgid "__ge__() (instance method)"
msgstr "__ge__() (metodo di istanza)"

#: library/stdtypes.rst:950
msgid "in"
msgstr "in"

#: library/stdtypes.rst:950
msgid "not in"
msgstr "non in"

#: library/stdtypes.rst:229 library/stdtypes.rst:393
msgid "integer"
msgstr "intero"

#: library/stdtypes.rst:229
msgid "floating point"
msgstr "punto flottante"

#: library/stdtypes.rst:229
msgid "complex number"
msgstr "numero complesso"

#: library/stdtypes.rst:208
msgid "C"
msgstr "C"

#: library/stdtypes.rst:208
msgid "language"
msgstr "linguaggio"

#: library/stdtypes.rst:229
msgid "literals"
msgstr "letterali"

#: library/stdtypes.rst:229
msgid "hexadecimal"
msgstr "esadecimale"

#: library/stdtypes.rst:229
msgid "octal"
msgstr "ottale"

#: library/stdtypes.rst:229
msgid "binary"
msgstr "binario"

#: library/stdtypes.rst:246
msgid "arithmetic"
msgstr "aritmetica"

#: library/stdtypes.rst:950 library/stdtypes.rst:4421 library/stdtypes.rst:5389
#: library/stdtypes.rst:5404
msgid "built-in function"
msgstr "funzione integrata"

#: library/stdtypes.rst:246
msgid "int"
msgstr "int"

#: library/stdtypes.rst:246
msgid "float"
msgstr "float"

#: library/stdtypes.rst:246
msgid "complex"
msgstr "complex"

#: library/stdtypes.rst:2389 library/stdtypes.rst:3607
msgid "+ (plus)"
msgstr "+ (più)"

#: library/stdtypes.rst:246
msgid "unary operator"
msgstr "operatore unario"

#: library/stdtypes.rst:246
msgid "binary operator"
msgstr "operatore binario"

#: library/stdtypes.rst:2389 library/stdtypes.rst:3607
msgid "- (minus)"
msgstr "- (meno)"

#: library/stdtypes.rst:2346 library/stdtypes.rst:3564
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: library/stdtypes.rst:246
msgid "/ (slash)"
msgstr "/ (barra)"

#: library/stdtypes.rst:246
msgid "//"
msgstr "//"

#: library/stdtypes.rst:2316 library/stdtypes.rst:3532
msgid "% (percent)"
msgstr "% (percento)"

#: library/stdtypes.rst:246
msgid "**"
msgstr "**"

#: library/stdtypes.rst:393 library/stdtypes.rst:1154 library/stdtypes.rst:4421
msgid "operations on"
msgstr "operazioni su"

#: library/stdtypes.rst:316
msgid "conjugate() (complex number method)"
msgstr "conjugate() (metodo numero complesso)"

#: library/stdtypes.rst:1605 library/stdtypes.rst:5404
msgid "module"
msgstr "modulo"

#: library/stdtypes.rst:335
msgid "math"
msgstr "math"

#: library/stdtypes.rst:335
msgid "floor() (in module math)"
msgstr "floor() (nel modulo math)"

#: library/stdtypes.rst:335
msgid "ceil() (in module math)"
msgstr "ceil() (nel modulo math)"

#: library/stdtypes.rst:335
msgid "trunc() (in module math)"
msgstr "trunc() (nel modulo math)"

#: library/stdtypes.rst:335
msgid "conversions"
msgstr "conversioni"

#: library/stdtypes.rst:393
msgid "bitwise"
msgstr "bitwise"

#: library/stdtypes.rst:393
msgid "shifting"
msgstr "shift"

#: library/stdtypes.rst:393
msgid "masking"
msgstr "mascheramento"

#: library/stdtypes.rst:393
msgid "| (vertical bar)"
msgstr "| (barra verticale)"

#: library/stdtypes.rst:393
msgid "^ (caret)"
msgstr "^ (circonflesso)"

#: library/stdtypes.rst:393
msgid "& (ampersand)"
msgstr "& (e commerciale)"

#: library/stdtypes.rst:393
msgid "<<"
msgstr "<<"

#: library/stdtypes.rst:393
msgid ">>"
msgstr ">>"

#: library/stdtypes.rst:393
msgid "~ (tilde)"
msgstr "~ (tilde)"

#: library/stdtypes.rst:817
msgid "values"
msgstr "valori"

#: library/stdtypes.rst:847
msgid "iterator protocol"
msgstr "protocollo iteratore"

#: library/stdtypes.rst:4814
msgid "protocol"
msgstr "protocollo"

#: library/stdtypes.rst:847
msgid "iterator"
msgstr "iteratore"

#: library/stdtypes.rst:934 library/stdtypes.rst:1117 library/stdtypes.rst:1154
msgid "sequence"
msgstr "sequenza"

#: library/stdtypes.rst:847
msgid "iteration"
msgstr "iterazione"

#: library/stdtypes.rst:847
msgid "container"
msgstr "contenitore"

#: library/stdtypes.rst:847
msgid "iteration over"
msgstr "iterazione su"

#: library/stdtypes.rst:4421
msgid "len"
msgstr "len"

#: library/stdtypes.rst:950
msgid "min"
msgstr "min"

#: library/stdtypes.rst:950
msgid "max"
msgstr "max"

#: library/stdtypes.rst:950
msgid "concatenation"
msgstr "concatenazione"

#: library/stdtypes.rst:950
msgid "operation"
msgstr "operazione"

#: library/stdtypes.rst:950
msgid "repetition"
msgstr "ripetizione"

#: library/stdtypes.rst:1154
msgid "subscript"
msgstr "sottoscrizione"

#: library/stdtypes.rst:1154
msgid "slice"
msgstr "slice"

#: library/stdtypes.rst:950
msgid "count() (sequence method)"
msgstr "count() (metodo sequenza)"

#: library/stdtypes.rst:950
msgid "index() (sequence method)"
msgstr "index() (metodo sequenza)"

#: library/stdtypes.rst:1006
msgid "loop"
msgstr "ciclo"

#: library/stdtypes.rst:1006
msgid "over mutable sequence"
msgstr "su sequenza mutabile"

#: library/stdtypes.rst:1006
msgid "mutable sequence"
msgstr "sequenza mutabile"

#: library/stdtypes.rst:1006
msgid "loop over"
msgstr "ciclo su"

#: library/stdtypes.rst:1117
msgid "immutable"
msgstr "immutabile"

#: library/stdtypes.rst:1338
msgid "tuple"
msgstr "tupla"

#: library/stdtypes.rst:1117
msgid "hash"
msgstr "hash"

#: library/stdtypes.rst:1139
msgid "mutable"
msgstr "mutable"

#: library/stdtypes.rst:1154 library/stdtypes.rst:1259
msgid "list"
msgstr "list"

#: library/stdtypes.rst:2513 library/stdtypes.rst:2711
#: library/stdtypes.rst:3532
msgid "bytearray"
msgstr "bytearray"

#: library/stdtypes.rst:4421 library/stdtypes.rst:5404
msgid "type"
msgstr "type"

#: library/stdtypes.rst:1154
msgid "assignment"
msgstr "assegnazione"

#: library/stdtypes.rst:4421
msgid "del"
msgstr "del"

#: library/stdtypes.rst:1154
msgid "append() (sequence method)"
msgstr "append() (metodo di sequenza)"

#: library/stdtypes.rst:1154
msgid "clear() (sequence method)"
msgstr "clear() (metodo di sequenza)"

#: library/stdtypes.rst:1154
msgid "copy() (sequence method)"
msgstr "copy() (metodo di sequenza)"

#: library/stdtypes.rst:1154
msgid "extend() (sequence method)"
msgstr "extend() (metodo di sequenza)"

#: library/stdtypes.rst:1154
msgid "insert() (sequence method)"
msgstr "insert() (metodo di sequenza)"

#: library/stdtypes.rst:1154
msgid "pop() (sequence method)"
msgstr "pop() (metodo di sequenza)"

#: library/stdtypes.rst:1154
msgid "remove() (sequence method)"
msgstr "remove() (metodo di sequenza)"

#: library/stdtypes.rst:1154
msgid "reverse() (sequence method)"
msgstr "reverse() (metodo di sequenza)"

#: library/stdtypes.rst:1382
msgid "range"
msgstr "range"

#: library/stdtypes.rst:1552 library/stdtypes.rst:2316
msgid "string"
msgstr "stringa"

#: library/stdtypes.rst:1503
msgid "text sequence type"
msgstr "tipo di sequenza di testo"

#: library/stdtypes.rst:1552 library/stdtypes.rst:1570
msgid "str (built-in class)"
msgstr "str (classe incorporata)"

#: library/stdtypes.rst:1503
msgid "(see also string)"
msgstr "(vedi anche stringa)"

#: library/stdtypes.rst:1539
msgid "io.StringIO"
msgstr "io.StringIO"

#: library/stdtypes.rst:2505
msgid "buffer protocol"
msgstr "protocollo buffer"

#: library/stdtypes.rst:2513 library/stdtypes.rst:2711
#: library/stdtypes.rst:3532
msgid "bytes"
msgstr "bytes"

#: library/stdtypes.rst:2711
msgid "methods"
msgstr "metodi"

#: library/stdtypes.rst:1605
msgid "re"
msgstr "re"

#: library/stdtypes.rst:3386
msgid "universal newlines"
msgstr "newline universali"

#: library/stdtypes.rst:2124
msgid "str.splitlines method"
msgstr "metodo str.splitlines"

#: library/stdtypes.rst:2316
msgid "formatting, string (%)"
msgstr "formattazione, stringa (%)"

#: library/stdtypes.rst:2316
msgid "interpolation, string (%)"
msgstr "interpolazione, stringa (%)"

#: library/stdtypes.rst:2316
msgid "formatting, printf"
msgstr "formattazione, printf"

#: library/stdtypes.rst:2316
msgid "interpolation, printf"
msgstr "interpolazione, printf"

#: library/stdtypes.rst:3532
msgid "printf-style formatting"
msgstr "formattazione stile printf"

#: library/stdtypes.rst:3532
msgid "sprintf-style formatting"
msgstr "formattazione stile sprintf"

#: library/stdtypes.rst:3564
msgid "() (parentheses)"
msgstr "() (parentesi)"

#: library/stdtypes.rst:2389 library/stdtypes.rst:3607
msgid "in printf-style formatting"
msgstr "nella formattazione stile printf"

#: library/stdtypes.rst:3564
msgid ". (dot)"
msgstr ". (punto)"

#: library/stdtypes.rst:3607
msgid "# (hash)"
msgstr "# (cancelletto)"

#: library/stdtypes.rst:3607
msgid "space"
msgstr "spazio"

#: library/stdtypes.rst:2505
msgid "binary sequence types"
msgstr "tipi di sequenze binarie"

#: library/stdtypes.rst:2513
msgid "memoryview"
msgstr "memoryview"

#: library/stdtypes.rst:2513
msgid "array"
msgstr "array"

#: library/stdtypes.rst:3386
msgid "bytes.splitlines method"
msgstr "metodo bytes.splitlines"

#: library/stdtypes.rst:3386
msgid "bytearray.splitlines method"
msgstr "metodo bytearray.splitlines"

#: library/stdtypes.rst:3532
msgid "formatting"
msgstr "formattazione"

#: library/stdtypes.rst:3532
msgid "bytes (%)"
msgstr "bytes (%)"

#: library/stdtypes.rst:3532
msgid "bytearray (%)"
msgstr "bytearray (%)"

#: library/stdtypes.rst:3532
msgid "interpolation"
msgstr "interpolazione"

#: library/stdtypes.rst:4219
msgid "set"
msgstr "set"

#: library/stdtypes.rst:4421
msgid "mapping"
msgstr "mapping"

#: library/stdtypes.rst:4421
msgid "dictionary"
msgstr "dizionario"

#: library/stdtypes.rst:4504
msgid "__missing__()"
msgstr "__missing__()"

#: library/stdtypes.rst:4814
msgid "context manager"
msgstr "gestore di contesto"

#: library/stdtypes.rst:4814
msgid "context management protocol"
msgstr "protocollo di gestione del contesto"

#: library/stdtypes.rst:4814
msgid "context management"
msgstr "gestione del contesto"

#: library/stdtypes.rst:4887
msgid "annotation"
msgstr "annotazione"

#: library/stdtypes.rst:4887
msgid "type annotation; type hint"
msgstr "annotazione di tipo; suggerimento di tipo"

#: library/stdtypes.rst:4899
msgid "GenericAlias"
msgstr "GenericAlias"

#: library/stdtypes.rst:4899
msgid "Generic"
msgstr "Generico"

#: library/stdtypes.rst:4899
msgid "Alias"
msgstr "Alias"

#: library/stdtypes.rst:5154
msgid "Union"
msgstr "Union"

#: library/stdtypes.rst:5154
msgid "union"
msgstr "unione"

#: library/stdtypes.rst:5324
msgid "method"
msgstr "metodo"

#: library/stdtypes.rst:5368
msgid "code"
msgstr "codice"

#: library/stdtypes.rst:5368
msgid "code object"
msgstr "oggetto codice"

#: library/stdtypes.rst:5375
msgid "compile"
msgstr "compilare"

#: library/stdtypes.rst:5375
msgid "__code__ (function object attribute)"
msgstr "__code__ (attributo dell'oggetto funzione)"

#: library/stdtypes.rst:5389
msgid "exec"
msgstr "exec"

#: library/stdtypes.rst:5389
msgid "eval"
msgstr "eval"

#: library/stdtypes.rst:5428
msgid "..."
msgstr "..."

#: library/stdtypes.rst:5428
msgid "ellipsis literal"
msgstr "letterale ellissi"

#~ msgid ""
#~ "Return a copy of the string with all occurrences of substring *old* "
#~ "replaced by *new*.  If *count* is given, only the first *count* "
#~ "occurrences are replaced. If *count* is not specified or ``-1``, then all "
#~ "occurrences are replaced."
#~ msgstr ""
#~ "Restituisce una copia della stringa con tutte le occorrenze della "
#~ "sottostringa *old* sostituite da *new*. Se è dato *count*, solo le prime "
#~ "*count* occorrenze vengono sostituite. Se *count* non è specificato o è "
#~ "``-1``, tutte le occorrenze vengono sostituite."

#~ msgid "*count* is now supported as a keyword argument."
#~ msgstr "*count* è ora supportato come argomento di parola chiave."

#~ msgid ""
#~ "A tuple containing names of attributes of this class which are accessed "
#~ "through ``self.X`` from any function in its body."
#~ msgstr ""
#~ "Una tupla contenente nomi di attributi di questa classe che sono "
#~ "accessibili tramite ``self.X`` da qualsiasi funzione nel suo corpo."

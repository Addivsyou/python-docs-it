# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-01 22:23+0200\n"
"PO-Revision-Date: 2024-05-31 09:19+0200\n"
"Last-Translator: Alessandro Cucci <alessandro.cucci@gmail.com>\n"
"Language-Team: \n"
"Language: it_IT\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 2.2.1\n"

#: tutorial/classes.rst:5
msgid "Classes"
msgstr "Classi"

#: tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Le classi forniscono un mezzo per raggruppare dati e funzionalità insieme. "
"Creare una nuova classe crea un nuovo *tipo* di oggetto, consentendo la "
"creazione di nuove *istanze* di quel tipo. Ogni istanza di classe può avere "
"attributi ad essa associati per mantenere il suo stato. Le istanze di classe "
"possono anche avere metodi (definiti dalla sua classe) per modificarne lo "
"stato."

#: tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Rispetto ad altri linguaggi di programmazione, il meccanismo delle classi di "
"Python aggiunge classi con un minimo di nuova sintassi e semantica. È un "
"misto dei meccanismi di classe trovati in C++ e Modula-3. Le classi Python "
"forniscono tutte le funzionalità standard della programmazione orientata "
"agli oggetti: il meccanismo di ereditarietà delle classi consente più classi "
"di base, una classe derivata può sovrascrivere qualsiasi metodo della sua "
"classe base o classi, e un metodo può chiamare il metodo di una classe di "
"base con lo stesso nome. Gli oggetti possono contenere quantità e tipi di "
"dati arbitrari. Come è vero per i moduli, le classi partecipano alla natura "
"dinamica di Python: sono create a tempo di esecuzione e possono essere "
"modificate ulteriormente dopo la creazione."

#: tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Nella terminologia di C++, normalmente i membri della classe (compresi i "
"membri dei dati) sono *pubblici* (tranne vedere sotto :ref:`tut-private`), e "
"tutte le funzioni membro sono *virtuali*. Come in Modula-3, non ci sono "
"abbreviazioni per fare riferimento ai membri dell'oggetto dai suoi metodi: "
"la funzione del metodo è dichiarata con un primo argomento esplicito che "
"rappresenta l'oggetto, che è fornito implicitamente dalla chiamata. Come in "
"Smalltalk, le classi stesse sono oggetti. Questo fornisce la semantica per "
"l'importazione e il ridenominare. A differenza di C++ e Modula-3, i tipi "
"integrati possono essere utilizzati come classi di base per l'estensione da "
"parte dell'utente. Inoltre, come in C++, la maggior parte degli operatori "
"integrati con una sintassi speciale (operatori aritmetici, indicizzazione "
"ecc.) possono essere ridefiniti per le istanze della classe."

#: tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Mancando una terminologia universalmente accettata per parlare di classi, "
"farò un uso occasionale dei termini Smalltalk e C++. Utilizzerei i termini "
"di Modula-3, poiché la sua semantica orientata agli oggetti è più vicina a "
"quella di Python rispetto a C++, ma mi aspetto che pochi lettori ne abbiano "
"sentito parlare.)"

#: tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Una parola su nomi e oggetti"

#: tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Gli oggetti hanno individualità e più nomi (in più ambiti) possono essere "
"vincolati allo stesso oggetto. Questo è noto come aliasing in altri "
"linguaggi. Questo di solito non è apprezzato a una prima occhiata a Python e "
"può essere tranquillamente ignorato quando si tratta di tipi di base "
"immutabili (numeri, stringhe, tuple). Tuttavia, l'aliasing ha un effetto "
"possibilmente sorprendente sulla semantica del codice Python che coinvolge "
"oggetti mutabili come liste, dizionari e la maggior parte degli altri tipi. "
"Questo è di solito usato a vantaggio del programma, poiché gli alias si "
"comportano come puntatori in alcuni aspetti. Ad esempio, passare un oggetto "
"è economico poiché viene passato solo un puntatore dall'implementazione; e "
"se una funzione modifica un oggetto passato come argomento, il chiamante "
"vedrà il cambiamento --- questo elimina la necessità di due diversi "
"meccanismi di passaggio degli argomenti come in Pascal."

#: tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Visibilità e spazi dei nomi in Python"

#: tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Prima di introdurre le classi, devo prima dirti qualcosa sulle regole di "
"visibilità di Python. Le definizioni di classe fanno alcuni trucchi "
"interessanti con gli spazi dei nomi e devi sapere come funzionano le "
"visibilità e gli spazi dei nomi per capire appieno cosa sta succedendo. Per "
"inciso, la conoscenza su questo argomento è utile per qualsiasi "
"programmatore Python avanzato."

#: tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Iniziamo con alcune definizioni."

#: tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Uno *spazio dei nomi* è una mappatura da nomi a oggetti. La maggior parte "
"degli spazi dei nomi è attualmente implementata come dizionari Python, ma "
"normalmente non è percepibile in alcun modo (tranne per le prestazioni) e "
"potrebbe cambiare in futuro. Esempi di spazi dei nomi sono: l'insieme di "
"nomi integrati (contenente funzioni come :func:`abs` e nomi di eccezioni "
"integrate); i nomi globali in un modulo; e i nomi locali in una chiamata di "
"funzione. In un certo senso, l'insieme di attributi di un oggetto forma "
"anche uno spazio dei nomi. La cosa importante da sapere sugli spazi dei nomi "
"è che non c'è assolutamente alcuna relazione tra nomi in spazi dei nomi "
"diversi; ad esempio, due moduli diversi possono entrambi definire una "
"funzione ``massimizza`` senza confusione --- gli utenti dei moduli devono "
"prefissarlo con il nome del modulo."

#: tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"A proposito, uso la parola *attributo* per qualsiasi nome che segue un punto "
"--- ad esempio, nell'espressione ``z.reale``, ``reale`` è un attributo "
"dell'oggetto ``z``. Più precisamente, i riferimenti ai nomi nei moduli sono "
"riferimenti agli attributi: nell'espressione ``nomemodulo.nomefunzione``, "
"``nomemodulo`` è un oggetto modulo e ``nomefunzione`` è un suo attributo. In "
"questo caso c'è una corrispondenza diretta tra gli attributi del modulo e i "
"nomi globali definiti nel modulo: condividono lo stesso spazio dei nomi! [#]_"

#: tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"Gli attributi possono essere di sola lettura o scrivibili. In quest'ultimo "
"caso, l'assegnazione agli attributi è possibile. Gli attributi del modulo "
"sono scrivibili: puoi scrivere ``nomemodulo.larisposta = 42``. Gli attributi "
"scrivibili possono anche essere eliminati con l'istruzione :keyword:`del`. "
"Ad esempio, ``del nomemodulo.larisposta`` rimuoverà l'attributo :attr:`!"
"larisposta` dall'oggetto denominato da ``nomemodulo``."

#: tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Gli spazi dei nomi sono creati in momenti diversi e hanno durate diverse. Lo "
"spazio dei nomi che contiene i nomi integrati è creato quando l'interprete "
"Python si avvia e non viene mai eliminato. Lo spazio dei nomi globale per un "
"modulo è creato quando la definizione del modulo viene letta; normalmente, "
"gli spazi dei nomi dei moduli durano anche fino a quando l'interprete non si "
"arresta. Le istruzioni eseguite dall'invocazione di livello superiore "
"dell'interprete, lette da un file di script o interattivamente, sono "
"considerate parte di un modulo chiamato :mod:`__main__`, quindi hanno il "
"loro proprio spazio dei nomi globale. (I nomi integrati in realtà vivono "
"anche in un modulo; questo si chiama :mod:`builtins`.)"

#: tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"Lo spazio dei nomi locale per una funzione è creato quando la funzione viene "
"chiamata e eliminato quando la funzione restituisce o genera un'eccezione "
"che non viene gestita all'interno della funzione. (In realtà, dimenticare "
"sarebbe un modo migliore per descrivere ciò che accade effettivamente.) "
"Naturalmente, le invocazioni ricorsive hanno ciascuna il proprio spazio dei "
"nomi locale."

#: tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"Uno *scope* è una regione testuale di un programma Python in cui uno spazio "
"dei nomi è direttamente accessibile. \"Direttamente accessibile\" qui "
"significa che un riferimento non qualificato a un nome tenta di trovare il "
"nome nello spazio dei nomi."

#: tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"Anche se gli scope sono determinati staticamente, vengono utilizzati "
"dinamicamente. In qualsiasi momento durante l'esecuzione, ci sono 3 o 4 "
"scope annidati i cui spazi dei nomi sono direttamente accessibili:"

#: tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"lo scope più interno, che viene cercato per primo, contiene i nomi locali"

#: tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"gli scope di eventuali funzioni contenenti, che vengono cercati a partire "
"dallo scope contenente più vicino, contengono nomi non locali, ma anche non "
"globali"

#: tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "il penultimo scope contiene i nomi globali del modulo corrente"

#: tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"lo scope più esterno (cercato per ultimo) è lo spazio dei nomi che contiene "
"i nomi integrati"

#: tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Se un nome è dichiarato globale, allora tutti i riferimenti e le "
"assegnazioni vanno direttamente allo scope penultimo contenente i nomi "
"globali del modulo. Per rilegare le variabili trovate al di fuori dello "
"scope più interno, può essere utilizzata l'istruzione :keyword:`nonlocal`; "
"se non dichiarate nonlocal, quelle variabili sono di sola lettura (un "
"tentativo di scrivere su una variabile del genere creerà semplicemente una "
"*nuova* variabile locale nello scope più interno, lasciando invariata la "
"variabile esterna con lo stesso nome)."

#: tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Di solito, lo scope locale fa riferimento ai nomi locali della funzione "
"(testualmente) corrente. Al di fuori delle funzioni, lo scope locale fa "
"riferimento allo stesso spazio dei nomi dello scope globale: lo spazio dei "
"nomi del modulo. Le definizioni di classe pongono un altro spazio dei nomi "
"nello scope locale."

#: tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"È importante rendersi conto che gli scope sono determinati testualmente: lo "
"scope globale di una funzione definita in un modulo è lo spazio dei nomi del "
"modulo, non importa da dove o con quale alias la funzione viene chiamata. "
"D'altra parte, la ricerca effettiva dei nomi viene fatta dinamicamente, a "
"tempo di esecuzione --- tuttavia, la definizione del linguaggio sta "
"evolvendo verso la risoluzione statica dei nomi, a tempo di "
"\"compilazione\", quindi non fare affidamento sulla risoluzione dinamica dei "
"nomi! (Infatti, le variabili locali sono già determinate staticamente.)"

#: tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"Una particolarità speciale di Python è che -- se non è in vigore alcuna "
"istruzione :keyword:`global` o :keyword:`nonlocal` -- le assegnazioni ai "
"nomi vanno sempre nello scope più interno. Le assegnazioni non copiano i "
"dati --- vincolano solo i nomi agli oggetti. Lo stesso vale per le "
"eliminazioni: l'istruzione ``del x`` rimuove il vincolo di ``x`` dallo "
"spazio dei nomi riferito dallo scope locale. In realtà, tutte le operazioni "
"che introducono nuovi nomi utilizzano lo scope locale: in particolare, le "
"istruzioni :keyword:`import` e le definizioni di funzioni vincolano il nome "
"del modulo o della funzione nello scope locale."

#: tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"L'istruzione :keyword:`global` può essere utilizzata per indicare che "
"particolari variabili vivono nello scope globale e dovrebbero essere "
"rilegate lì; l'istruzione :keyword:`nonlocal` indica che particolari "
"variabili vivono in uno scope circoscritto e dovrebbero essere rilegate lì."

#: tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Esempio di visibilità e spazi dei nomi"

#: tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Questo è un esempio che dimostra come fare riferimento ai diversi scope e "
"spazi dei nomi e come :keyword:`global` e :keyword:`nonlocal` influenzano il "
"vincolo delle variabili::"

#: tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "L'output del codice di esempio è:"

#: tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Nota come l'assegnazione *locale* (che è predefinita) non abbia cambiato il "
"vincolo di *spam* di *scope_test*. L'assegnazione :keyword:`nonlocal` ha "
"cambiato il vincolo di *spam* di *scope_test* e l'assegnazione :keyword:"
"`global` ha cambiato il vincolo a livello di modulo."

#: tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Si può anche vedere che non c'era alcun vincolo precedente per *spam* prima "
"dell'assegnazione :keyword:`global`."

#: tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Una prima occhiata alle classi"

#: tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Le classi introducono un po' di nuova sintassi, tre nuovi tipi di oggetti e "
"alcune nuove semantiche."

#: tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Sintassi della definizione di classe"

#: tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "La forma più semplice di definizione di classe appare così::"

#: tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Le definizioni di classe, come le definizioni di funzione (istruzioni :"
"keyword:`def`), devono essere eseguite prima di avere effetto. (Potresti "
"concepibilmente collocare una definizione di classe in un ramo di "
"un'istruzione :keyword:`if` o all'interno di una funzione.)"

#: tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"In pratica, le istruzioni all'interno di una definizione di classe saranno "
"solitamente definizioni di funzioni, ma sono ammesse e talvolta utili --- "
"torneremo su questo più tardi. Le definizioni di funzioni all'interno di una "
"classe hanno normalmente una forma peculiare di elenco degli argomenti, "
"dettata dalle convenzioni di chiamata per i metodi --- anche questo è "
"spiegato più tardi."

#: tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Quando una definizione di classe viene inserita, viene creato un nuovo "
"spazio dei nomi e utilizzato come scope locale --- quindi, tutte le "
"assegnazioni alle variabili locali vanno in questo nuovo spazio dei nomi. In "
"particolare, qui le definizioni di funzioni vincolano il nome della nuova "
"funzione."

#: tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""
"Quando una definizione di classe viene lasciata normalmente (tramite la "
"fine), viene creato un *oggetto classe*. Questo è essenzialmente un wrapper "
"attorno ai contenuti dello spazio dei nomi creato dalla definizione di "
"classe; impareremo di più sugli oggetti classe nella sezione successiva. Lo "
"scope locale originale (quello in vigore appena prima che la definizione di "
"classe fosse inserita) viene ripristinato e l'oggetto classe è vincolato qui "
"al nome della classe dato dall'intestazione della definizione di classe (:"
"class:`!NomeClasse` nell'esempio)."

#: tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Oggetti della Classe"

#: tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Gli oggetti della classe supportano due tipi di operazioni: riferimenti agli "
"attributi e istanziazione."

#: tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"I *riferimenti agli attributi* utilizzano la sintassi standard utilizzata "
"per tutti i riferimenti agli attributi in Python: ``oggetto.nome``. I nomi "
"degli attributi validi sono tutti i nomi che erano nello spazio dei nomi "
"della classe quando l'oggetto classe è stato creato. Quindi, se la "
"definizione della classe apparisse così::"

#: tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`!__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"allora ``MyClass.i`` e ``MyClass.f`` sono riferimenti agli attributi validi, "
"restituendo rispettivamente un intero e un oggetto funzione. Gli attributi "
"di classe possono anche essere assegnati, quindi puoi cambiare il valore di "
"``MyClass.i`` per assegnazione. :attr:`!__doc__` è anche un attributo "
"valido, restituendo la stringa di documentazione appartenente alla classe: "
"``\"Una classe di esempio semplice\"``."

#: tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"L'*istanziamento* della classe utilizza la notazione funzionale. Basta "
"immaginare che l'oggetto classe sia una funzione senza parametri che "
"restituisce una nuova istanza della classe. Per esempio (assumendo la classe "
"sopra menzionata)::"

#: tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"crea una nuova *istanza* della classe e assegna questo oggetto alla "
"variabile locale ``x``."

#: tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""
"L'operazione di istanziazione (\"chiamare\" un oggetto classe) crea un "
"oggetto vuoto. Molte classi preferiscono creare oggetti con istanze "
"personalizzate per uno stato iniziale specifico. Pertanto, una classe può "
"definire un metodo speciale chiamato :meth:`~object.__init__`, come questo::"

#: tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Quando una classe definisce un metodo :meth:`~object.__init__`, "
"l'istanziamento della classe invoca automaticamente :meth:`!__init__` per la "
"nuova istanza della classe creata. Quindi, in questo esempio, una nuova "
"istanza inizializzata può essere ottenuta con::"

#: tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"Ovviamente, il metodo :meth:`~object.__init__` può avere argomenti per una "
"maggiore flessibilità. In tal caso, gli argomenti forniti all'operatore di "
"istanziazione della classe vengono passati a :meth:`!__init__`. Per "
"esempio, ::"

#: tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Oggetti Istanza"

#: tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Ora, cosa possiamo fare con gli oggetti istanza? Le uniche operazioni "
"comprese dagli oggetti istanza sono i riferimenti agli attributi. Ci sono "
"due tipi di nomi di attributi validi: attributi dati e metodi."

#: tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"Gli *attributi dati* corrispondono alle \"variabili di istanza\" in "
"Smalltalk, e ai \"membri dati\" in C++. Gli attributi dati non devono essere "
"dichiarati; come le variabili locali, nascono nel momento in cui vengono "
"assegnati per la prima volta. Per esempio, se ``x`` è l'istanza di :class:`!"
"MyClass` creata sopra, il seguente pezzo di codice stamperà il valore "
"``16``, senza lasciare traccia::"

#: tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"L'altro tipo di riferimento agli attributi dell'istanza è un *metodo*. Un "
"metodo è una funzione che \"appartiene a\" un oggetto. (In Python, il "
"termine metodo non è unico per le istanze di classe: altri tipi di oggetti "
"possono avere metodi. Ad esempio, gli oggetti lista hanno metodi chiamati "
"append, insert, remove, sort, e così via. Tuttavia, nella discussione che "
"segue, useremo il termine metodo esclusivamente per indicare i metodi degli "
"oggetti istanza di classe, a meno che non sia esplicitamente dichiarato "
"diversamente.)"

#: tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"I nomi dei metodi validi di un oggetto istanza dipendono dalla sua classe. "
"Per definizione, tutti gli attributi di una classe che sono oggetti funzione "
"definiscono i metodi corrispondenti delle sue istanze. Quindi nel nostro "
"esempio, ``x.f`` è un riferimento a un metodo valido, poiché ``MyClass.f`` è "
"una funzione, ma ``x.i`` no, poiché ``MyClass.i`` non lo è. Tuttavia, ``x."
"f`` non è la stessa cosa di ``MyClass.f`` --- è un *oggetto metodo*, non un "
"oggetto funzione."

#: tutorial/classes.rst:360
msgid "Method Objects"
msgstr "Oggetti Metodo"

#: tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr ""
"Di solito, un metodo viene chiamato subito dopo essere stato associato::"

#: tutorial/classes.rst:366
msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"Nell'esempio :class:`!MyClass`, questo restituirà la stringa ``'hello "
"world'``. Tuttavia, non è necessario chiamare un metodo subito: ``x.f`` è un "
"oggetto metodo e può essere memorizzato e chiamato in un secondo momento. "
"Per esempio::"

#: tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "continuerà a stampare ``hello world`` fino alla fine dei tempi."

#: tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Cosa succede esattamente quando un metodo viene chiamato? Potreste aver "
"notato che ``x.f()`` è stato chiamato senza argomento sopra, anche se la "
"definizione della funzione per :meth:`!f` specifica un argomento. Che fine "
"ha fatto l'argomento? Sicuramente Python solleva un'eccezione quando una "
"funzione che richiede un argomento viene chiamata senza alcuno --- anche se "
"l'argomento non è effettivamente usato..."

#: tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"In realtà, potreste aver indovinato la risposta: la caratteristica speciale "
"dei metodi è che l'istanza dell'oggetto viene passata come primo argomento "
"della funzione. Nel nostro esempio, la chiamata ``x.f()`` è esattamente "
"equivalente a ``MyClass.f(x)``. In generale, chiamare un metodo con una "
"lista di *n* argomenti è equivalente a chiamare la funzione corrispondente "
"con una lista di argomenti creata inserendo l'istanza del metodo prima del "
"primo argomento."

#: tutorial/classes.rst:389
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""
"In generale, i metodi funzionano come segue. Quando viene referenziato un "
"attributo non dato di un'istanza, viene cercata la classe dell'istanza. Se "
"il nome denota un attributo di classe valido che è un oggetto funzione, i "
"riferimenti all'istanza dell'oggetto e all'oggetto funzione vengono "
"impacchettati in un oggetto metodo. Quando l'oggetto metodo viene chiamato "
"con una lista di argomenti, viene costruita una nuova lista di argomenti "
"dall'istanza dell'oggetto e la lista degli argomenti, e l'oggetto funzione "
"viene chiamato con questa nuova lista di argomenti."

#: tutorial/classes.rst:402
msgid "Class and Instance Variables"
msgstr "Variabili di Classe e Istanza"

#: tutorial/classes.rst:404
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"Generalmente parlando, le variabili di istanza sono per i dati unici a "
"ciascuna istanza e le variabili di classe sono per gli attributi e i metodi "
"condivisi da tutte le istanze della classe::"

#: tutorial/classes.rst:426
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Come discusso in :ref:`tut-object`, i dati condivisi possono avere effetti "
"potenzialmente sorprendenti coinvolgendo oggetti :term:`mutable` come liste "
"e dizionari. Per esempio, la lista *tricks* nel seguente codice non dovrebbe "
"essere usata come variabile di classe perché solo una singola lista verrebbe "
"condivisa da tutte le istanze di *Dog*::"

#: tutorial/classes.rst:449
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Il design corretto della classe dovrebbe usare una variabile di istanza "
"invece::"

#: tutorial/classes.rst:473
msgid "Random Remarks"
msgstr "Osservazioni Varie"

#: tutorial/classes.rst:477
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Se lo stesso nome di attributo appare sia in un'istanza che in una classe, "
"la ricerca degli attributi dà priorità all'istanza::"

#: tutorial/classes.rst:492
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Gli attributi dati possono essere referenziati dai metodi così come dagli "
"utenti ordinari (\"clienti\") di un oggetto. In altre parole, le classi non "
"sono utilizzabili per implementare tipi di dati astratti puri. Infatti, "
"nulla in Python permette di imporre l'incapsulamento dei dati --- è tutto "
"basato su convenzioni. (D'altra parte, l'implementazione di Python, scritta "
"in C, può nascondere completamente i dettagli di implementazione e "
"controllare l'accesso a un oggetto se necessario; questo può essere "
"utilizzato dalle estensioni a Python scritte in C.)"

#: tutorial/classes.rst:500
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"I clienti dovrebbero usare gli attributi dati con cautela --- i clienti "
"potrebbero infrangere gli invarianti mantenuti dai metodi alterando i loro "
"attributi dati. Si noti che i clienti possono aggiungere attributi dati "
"propri a un oggetto istanza senza influenzare la validità dei metodi, purché "
"vengano evitati conflitti di nomi --- ancora una volta, una convenzione di "
"nomenclatura può risparmiare molti mal di testa."

#: tutorial/classes.rst:506
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Non c'è alcuna scorciatoia per riferirsi agli attributi dati (o ad altri "
"metodi!) dall'interno dei metodi. Trovo che questo in realtà aumenti la "
"leggibilità dei metodi: non c'è possibilità di confondere variabili locali e "
"variabili di istanza quando si scorre un metodo."

#: tutorial/classes.rst:511
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Spesso, il primo argomento di un metodo è chiamato ``self``. Questa è niente "
"più che una convenzione: il nome ``self`` non ha assolutamente alcun "
"significato speciale per Python. Tieni presente, tuttavia, che non seguire "
"la convenzione potrebbe rendere il tuo codice meno leggibile per altri "
"programmatori Python, e non è nemmeno impossibile che venga scritto un "
"programma *class browser* che si basa su tale convenzione."

#: tutorial/classes.rst:517
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Qualsiasi oggetto funzione che è un attributo di classe definisce un metodo "
"per le istanze di quella classe. Non è necessario che la definizione della "
"funzione sia testualmente inclusa nella definizione della classe: è anche "
"possibile assegnare un oggetto funzione a una variabile locale nella classe. "
"Per esempio::"

#: tutorial/classes.rst:534
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"Ora ``f``, ``g`` e ``h`` sono tutti attributi della classe :class:`!C` che "
"si riferiscono a oggetti funzione, e di conseguenza sono tutti metodi delle "
"istanze della classe :class:`!C` --- ``h`` essendo esattamente equivalente a "
"``g``. Si noti che questa pratica di solito solo serve a confondere il "
"lettore di un programma."

#: tutorial/classes.rst:539
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"I metodi possono chiamare altri metodi utilizzando gli attributi di metodo "
"dell'argomento ``self``::"

#: tutorial/classes.rst:553
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"I metodi possono referenziare nomi globali allo stesso modo delle funzioni "
"ordinarie. Lo scope globale associato a un metodo è il modulo contenente la "
"sua definizione. (Una classe non è mai utilizzata come uno scope globale.) "
"Sebbene raramente si incontri una buona ragione per usare dati globali in un "
"metodo, ci sono molti usi legittimi dello scope globale: ad esempio, le "
"funzioni e i moduli importati nello scope globale possono essere utilizzati "
"dai metodi, così come le funzioni e le classi definite in esso. Di solito, "
"la classe contenente il metodo è definita anch'essa in tale scope globale, e "
"nella sezione successiva troveremo alcune buone ragioni per cui un metodo "
"potrebbe voler referenziare la propria classe."

#: tutorial/classes.rst:563
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Ogni valore è un oggetto e quindi ha una *classe* (chiamata anche il suo "
"*tipo*). È memorizzato come ``object.__class__``."

#: tutorial/classes.rst:570
msgid "Inheritance"
msgstr "Ereditarietà"

#: tutorial/classes.rst:572
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Naturalmente, una caratteristica del linguaggio non sarebbe degna del nome "
"\"classe\" senza supportare l'ereditarietà. La sintassi per la definizione "
"di una classe derivata è simile::"

#: tutorial/classes.rst:583
msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace accessible "
"from the scope containing the derived class definition.  In place of a base "
"class name, other arbitrary expressions are also allowed.  This can be "
"useful, for example, when the base class is defined in another module::"
msgstr ""
"Il nome :class:`!BaseClassName` deve essere definito in uno spazio dei nomi "
"accessibile dallo scope contenente la definizione della classe derivata. Al "
"posto di un nome di classe base, sono permesse anche altre espressioni "
"arbitrarie. Questo può essere utile, per esempio, quando la classe base è "
"definita in un altro modulo::"

#: tutorial/classes.rst:591
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"L'esecuzione di una definizione di classe derivata procede nello stesso modo "
"di una classe base. Quando viene costruito l'oggetto classe, viene ricordata "
"la classe base. Questo viene utilizzato per risolvere i riferimenti agli "
"attributi: se un attributo richiesto non è trovato nella classe, la ricerca "
"procede a cercarlo nella classe base. Questa regola viene applicata "
"ricorsivamente se la classe base stessa è derivata da un'altra classe."

#: tutorial/classes.rst:597
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Non c'è nulla di speciale nell'istanza di classi derivate: "
"``DerivedClassName()`` crea una nuova istanza della classe. I riferimenti ai "
"metodi vengono risolti come segue: viene cercato l'attributo di classe "
"corrispondente, scendendo lungo la catena delle classi base se necessario, e "
"il riferimento al metodo è valido se questo produce un oggetto funzione."

#: tutorial/classes.rst:603
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Le classi derivate possono ignorare i metodi delle loro classi base. Poiché "
"i metodi non hanno privilegi speciali quando chiamano altri metodi dello "
"stesso oggetto, un metodo di una classe base che chiama un altro metodo "
"definito nella stessa classe base può finire per chiamare un metodo di una "
"classe derivata che lo sostituisce. (Per programmatori C++: tutti i metodi "
"in Python sono effettivamente ``virtual``.)"

#: tutorial/classes.rst:609
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Un metodo sovrascritto in una classe derivata può in realtà voler estendere "
"piuttosto che semplicemente sostituire il metodo della classe base con lo "
"stesso nome. C'è un modo semplice per chiamare direttamente il metodo della "
"classe base: basta chiamare ``BaseClassName.methodname(self, arguments)``. "
"Questo è occasionalmente utile anche per i clienti. (Si noti che questo "
"funziona solo se la classe base è accessibile come ``BaseClassName`` nello "
"scope globale.)"

#: tutorial/classes.rst:616
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python ha due funzioni built-in che funzionano con l'ereditarietà:"

#: tutorial/classes.rst:618
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Usa :func:`isinstance` per controllare il tipo di un'istanza: "
"``isinstance(obj, int)`` sarà ``True`` solo se ``obj.__class__`` è :class:"
"`int` o una classe derivata da :class:`int`."

#: tutorial/classes.rst:622
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Usa :func:`issubclass` per controllare l'ereditarietà delle classi: "
"``issubclass(bool, int)`` è ``True`` poiché :class:`bool` è una sottoclasse "
"di :class:`int`. Tuttavia, ``issubclass(float, int)`` è ``False`` poiché :"
"class:`float` non è una sottoclasse di :class:`int`."

#: tutorial/classes.rst:632
msgid "Multiple Inheritance"
msgstr "Ereditarietà Multipla"

#: tutorial/classes.rst:634
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python supporta anche una forma di ereditarietà multipla. Una definizione di "
"classe con più classi base è simile::"

#: tutorial/classes.rst:644
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"Per la maggior parte degli scopi, nei casi più semplici, si può pensare alla "
"ricerca di attributi ereditati da una classe padre come alla profondità "
"prima, da sinistra a destra, senza cercare due volte nella stessa classe "
"dove c'è una sovrapposizione nella gerarchia. Pertanto, se un attributo non "
"viene trovato in :class:`!DerivedClassName`, viene cercato in :class:`!"
"Base1`, quindi (ricorsivamente) nelle classi base di :class:`!Base1`, e se "
"non è stato trovato lì, viene cercato in :class:`!Base2`, e così via."

#: tutorial/classes.rst:651
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"Infatti, è leggermente più complesso di così; l'ordine di risoluzione del "
"metodo cambia dinamicamente per supportare le chiamate cooperative a :func:"
"`super`. Questo approccio è noto in altri linguaggi con ereditarietà "
"multipla come call-next-method ed è più potente della chiamata super trovata "
"nei linguaggi a ereditarietà singola."

#: tutorial/classes.rst:657
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see :ref:`python_2.3_mro`."
msgstr ""
"L'ordinamento dinamico è necessario perché tutti i casi di ereditarietà "
"multipla mostrano una o più relazioni di diamante (dove almeno una delle "
"classi padre può essere accessibile attraverso percorsi multipli dalla "
"classe più bassa). Per esempio, tutte le classi ereditano da :class:"
"`object`, quindi qualsiasi caso di ereditarietà multipla fornisce più di un "
"percorso per raggiungere :class:`object`. Per evitare che le classi base "
"vengano accessibili più di una volta, l'algoritmo dinamico linearizza "
"l'ordine di ricerca in modo che preserva l'ordunquezione da sinistra a "
"destra specificata in ogni classe, che chiama ogni genitore solo una volta, "
"e che è monotònico (significando che una classe può essere sottoclasse senza "
"influenzare l'ordine di precedenza dei suoi genitori). Insieme, queste "
"proprietà rendono possibile progettare classi affidabili ed estensibili con "
"ereditarietà multipla. Per maggiori dettagli, vedi :ref:`python_2.3_mro`."

#: tutorial/classes.rst:674
msgid "Private Variables"
msgstr "Variabili Private"

#: tutorial/classes.rst:676
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Non esistono variabili di istanza \"private\" che non possono essere "
"accessibili se non all'interno di un oggetto in Python. Tuttavia, c'è una "
"convenzione seguita dalla maggior parte del codice Python: un nome prefisso "
"con un trattino basso (es. ``_spam``) dovrebbe essere trattato come una "
"parte non pubblica dell'API (sia che sia una funzione, un metodo o un membro "
"dato). Dovrebbe essere considerato un dettaglio di implementazione e "
"soggetto a cambiamento senza preavviso."

#: tutorial/classes.rst:686
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Poiché esiste un caso d'uso valido per i membri privati della classe (ovvero "
"per evitare conflitti di nomi con nomi definiti dalle sottoclassi), c'è un "
"supporto limitato per tale meccanismo, chiamato :dfn:`offuscamento dei "
"nomi`. Qualsiasi identificatore della forma ``__spam`` (almeno due trattini "
"bassi iniziali, al massimo uno finale) è testualmente sostituito con "
"``_classname__spam``, dove ``classname`` è il nome attuale della classe con "
"i trattini bassi iniziali rimossi. Questo offuscamento viene eseguito senza "
"riguardo alla posizione sintattica dell'identificatore, purché si trovi "
"all'interno della definizione di una classe."

#: tutorial/classes.rst:695
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"L'offuscamento dei nomi è utile per permettere alle sottoclassi di "
"sovrascrivere i metodi senza rompere le chiamate ai metodi interni alla "
"classe. Per esempio::"

#: tutorial/classes.rst:717
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"L'esempio sopra funzionerebbe anche se ``MappingSubclass`` dovesse "
"introdurre un identificatore ``__update`` poiché viene sostituito con "
"``_Mapping__update`` nella classe ``Mapping`` e ``_MappingSubclass__update`` "
"nella classe ``MappingSubclass`` rispettivamente."

#: tutorial/classes.rst:722
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Si noti che le regole di offuscamento sono progettate soprattutto per "
"evitare incidenti; è ancora possibile accedere o modificare una variabile "
"considerata privata. Questo può essere utile in circostanze speciali, come "
"nel debugger."

#: tutorial/classes.rst:726
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Si noti che il codice passato a ``exec()`` o ``eval()`` non considera la "
"classe nome dell'invocante per essere la classe attuale; questo è simile "
"all'effetto della dichiarazione ``global``, l'effetto del quale è "
"analogamente limitato al codice che è compilato insieme. La stessa "
"restrizione si applica a ``getattr()``, ``setattr()`` e ``delattr()``, così "
"come quando si fa riferimento direttamente a ``__dict__``."

#: tutorial/classes.rst:737
msgid "Odds and Ends"
msgstr "Varie ed Eventuali"

#: tutorial/classes.rst:739
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"A volte è utile avere un tipo di dato simile al \"record\" del Pascal o al "
"\"struct\" del C, raggruppando insieme alcuni elementi dati con nome. "
"L'approccio idiomatico è utilizzare :mod:`dataclasses` per questo scopo::"

#: tutorial/classes.rst:759
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"Un pezzo di codice Python che si aspetta un particolare tipo di dato "
"astratto può spesso essere passato a una classe che emula i metodi di quel "
"tipo di dato. Per esempio, se hai una funzione che formatta alcuni dati da "
"un oggetto file, puoi definire una classe con i metodi :meth:`~io.TextIOBase."
"read` e :meth:`~io.TextIOBase.readline` che ottengono i dati da un buffer di "
"stringhe, e passarla come argomento."

#: tutorial/classes.rst:771
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
"Gli :ref:`oggetti metodo d'istanza <instance-methods>` hanno anch'essi "
"attributi: :attr:`m.__self__ <method.__self__>` è l'oggetto istanza con il "
"metodo :meth:`!m`, e :attr:`m.__func__ <method.__func__>` è l':ref:`oggetto "
"funzione <user-defined-funcs>` corrispondente al metodo."

#: tutorial/classes.rst:781
msgid "Iterators"
msgstr "Iteratori"

#: tutorial/classes.rst:783
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Ormai avrai probabilmente notato che la maggior parte degli oggetti "
"contenitori può essere iterata utilizzando un'istruzione :keyword:`for`::"

#: tutorial/classes.rst:797
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Questo stile di accesso è chiaro, conciso e conveniente. L'uso degli "
"iteratori permea e unifica Python. Dietro le quinte, l'istruzione :keyword:"
"`for` chiama la funzione :func:`iter` sull'oggetto contenitore. La funzione "
"restituisce un oggetto iteratore che definisce il metodo :meth:`~iterator."
"__next__` che accede agli elementi del contenitore uno alla volta. Quando "
"non ci sono più elementi, :meth:`~iterator.__next__` solleva un'eccezione :"
"exc:`StopIteration` che indica al ciclo :keyword:`!for` di terminare. Puoi "
"chiamare il metodo :meth:`~iterator.__next__` utilizzando la funzione built-"
"in :func:`next`; questo esempio mostra come funziona tutto::"

#: tutorial/classes.rst:822
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""
"Avendo visto la meccanica dietro il protocollo dell'iteratore, è facile "
"aggiungere il comportamento di iteratore alle tue classi. Definisci un "
"metodo :meth:`~container.__iter__` che restituisce un oggetto con un metodo :"
"meth:`~iterator.__next__`. Se la classe definisce :meth:`!__next__`, allora :"
"meth:`!__iter__` può semplicemente restituire ``self``::"

#: tutorial/classes.rst:859
msgid "Generators"
msgstr "Generatori"

#: tutorial/classes.rst:861
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
"I :term:`generatori <generator>` sono uno strumento semplice e potente per "
"creare iteratori. Sono scritti come funzioni regolari ma utilizzano "
"l'istruzione :keyword:`yield` ogni volta che vogliono restituire dati. Ogni "
"volta che si chiama :func:`next` su di esso, il generatore riprende da dove "
"si era interrotto (ricorda tutti i valori dei dati e quale istruzione è "
"stata eseguita per ultima). Un esempio mostra che i generatori possono "
"essere creati con estrema facilità::"

#: tutorial/classes.rst:882
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""
"Tutto ciò che può essere fatto con i generatori può essere fatto anche con "
"gli iteratori basati su classi come descritto nella sezione precedente. Ciò "
"che rende i generatori così compatti è che i metodi :meth:`~iterator."
"__iter__` e :meth:`~generator.__next__` sono creati automaticamente."

#: tutorial/classes.rst:887
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Un'altra caratteristica chiave è che le variabili locali e lo stato di "
"esecuzione sono salvati automaticamente tra le chiamate. Questo rende la "
"funzione più facile da scrivere e molto più chiara rispetto a un approccio "
"che utilizza variabili di istanza come ``self.index`` e ``self.data``."

#: tutorial/classes.rst:892
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Oltre alla creazione automatica dei metodi e al salvataggio dello stato del "
"programma, quando i generatori terminano, sollevano automaticamente :exc:"
"`StopIteration`. In combinazione, queste caratteristiche rendono facile "
"creare iteratori con lo stesso sforzo di scrivere una funzione regolare."

#: tutorial/classes.rst:901
msgid "Generator Expressions"
msgstr "Espressioni di Generatore"

#: tutorial/classes.rst:903
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Alcuni generatori semplici possono essere codificati in modo conciso come "
"espressioni utilizzando una sintassi simile alle comprensioni di lista ma "
"con parentesi tonde anziché quadre. Queste espressioni sono progettate per "
"situazioni in cui il generatore viene utilizzato immediatamente da una "
"funzione racchiudente. Le espressioni di generatore sono più compatte ma "
"meno versatili rispetto alle definizioni complete di generatore e tendono a "
"essere più efficienti in termini di memoria rispetto alle comprensioni di "
"lista equivalenti."

#: tutorial/classes.rst:910
msgid "Examples::"
msgstr "Esempi::"

#: tutorial/classes.rst:931
msgid "Footnotes"
msgstr "Note a piè di pagina"

#: tutorial/classes.rst:932
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Tranne per una cosa. Gli oggetti modulo hanno un attributo segreto di sola "
"lettura chiamato :attr:`~object.__dict__` che restituisce il dizionario "
"usato per implementare lo spazio dei nomi del modulo; il nome :attr:`~object."
"__dict__` è un attributo ma non un nome globale. Ovviamente, l'uso di questo "
"violerebbe l'astrazione dell'implementazione dello spazio dei nomi e "
"dovrebbe essere limitato a cose come debugger post-mortem."

#: tutorial/classes.rst:347
msgid "object"
msgstr "oggetto"

#: tutorial/classes.rst:347
msgid "method"
msgstr "metodo"

#: tutorial/classes.rst:683
msgid "name"
msgstr "nome"

#: tutorial/classes.rst:683
msgid "mangling"
msgstr "offuscamento"
